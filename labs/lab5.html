<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-06">

<title>lab5 – E155 portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-42c556fe1a289823da7f919bab4d1b2a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">E155 portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-labs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Labs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-labs">    
        <li>
    <a class="dropdown-item" href="../labs/lab1.html">
 <span class="dropdown-text">Lab1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab2.html">
 <span class="dropdown-text">Lab2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab3.html">
 <span class="dropdown-text">Lab3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab4.html">
 <span class="dropdown-text">Lab4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab5.html">
 <span class="dropdown-text">Lab5</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab6.html">
 <span class="dropdown-text">Lab6</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../labs/lab7.html">
 <span class="dropdown-text">Lab7</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lab-5-interrupts" id="toc-lab-5-interrupts" class="nav-link active" data-scroll-target="#lab-5-interrupts">Lab 5 Interrupts</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a>
  <ul class="collapse">
  <li><a href="#equations" id="toc-equations" class="nav-link" data-scroll-target="#equations">Equations</a></li>
  </ul></li>
  <li><a href="#results" id="toc-results" class="nav-link" data-scroll-target="#results">Results</a></li>
  <li><a href="#interrupt-vs-polling" id="toc-interrupt-vs-polling" class="nav-link" data-scroll-target="#interrupt-vs-polling">Interrupt vs polling</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#suggestions" id="toc-suggestions" class="nav-link" data-scroll-target="#suggestions">Suggestions</a></li>
  <li><a href="#ai-prototype" id="toc-ai-prototype" class="nav-link" data-scroll-target="#ai-prototype">AI Prototype</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
  <div class="quarto-categories">
    <div class="quarto-category">labreport</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 6, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="lab-5-interrupts" class="level2">
<h2 class="anchored" data-anchor-id="lab-5-interrupts">Lab 5 Interrupts</h2>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In this lab, a design was made to use a microcontroller to determine the speed of a brushed DC motor by reading a quadrature encoder using interrupts. To do this, code was written in C to sense quadrature encoder pulses, and in turn, turn those pulses into motor velocities. The function of a quadrature encoder is to use an incremental motion sensor that uses two output signals offset by 90 degrees to provide both positional and directional information for a motor. An animation of an encoder can be see below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/encoder.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1: Animation of quadrature encoder</figcaption>
</figure>
</div>
<p>Above is the quadrature encoder used for this lab. The disk rotates with the motor.</p>
<p>The design was developed using C on SEGGER, and implemented on an STM32L432KC Microcontroller.</p>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h2>
<p>The source code for this lab can be found in this <a href="https://github.com/Swayngee/e155-lab1/tree/main/fpga/src/lab5">GitHub repo</a>.</p>
<p>The documentation for the STM32L432KC manual <a href="https://hmc-e155.github.io/assets/doc/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf">Github link</a>.</p>
<p>The source Instruction to cycles documentation <a href="https://developer.arm.com/documentation/ddi0439/b/CHDDIGAC">ARM website</a>.</p>
<section id="equations" class="level3">
<h3 class="anchored" data-anchor-id="equations">Equations</h3>
<p>The only equations applicable to this lab are the ones used to calculate how many edges to account for. The equation used was:</p>
<p>revolutions = position (1000/timer) / (4 x 408)</p>
<p>This equation multiplies the encoder count (position counter) by the sampling rate (samples per second), then divides by the total number of quadrature edges per revolution.</p>
<p>An example of this equation in the works can be seen below. Below is an osilliscope frame of the output of the B encoder. This occured at 10V input into the motor.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/example5.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 2: Animation of quadrature encoder</figcaption>
</figure>
</div>
<p>Each square wave period corresponds to one pulse of the encoder signal. The frequency of these pulses increases with motor speed, which is directly controlled by the input voltage.</p>
<p>We know that f = 1/T -&gt; 970Hz</p>
<p>Using the relationship between speed, frequency, and PPR we get:</p>
<p>speed (rev/s) = f / PPR -&gt; 2.37 rev/s</p>
<p>When comparing this to the actual value measured by our interrupts, we can see the same value. As seen below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/speedlab5.png" class="img-fluid figure-img"></p>
<figcaption>Figure 3: Speed values printed in debug terminal</figcaption>
</figure>
</div>
<p>Above are the values that we were getting from our debug terminal from our interrupt code. These values, when compared to our theoretical values, are within a 1% margin. Thus validating the output coming from our code.</p>
<p><strong>Flowchart</strong></p>
<p>Below is my logic flowchart for this lab. It features important calls to certain functions, and goes through the flow for the main loop within this design.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/blocks.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 4: Flowchart</figcaption>
</figure>
</div>
<p>Figure 4 shows the functions: main, initAB, GPIOenable, timeable, and the interupt handler EXTI_IRQHandler.</p>
<p><strong>Wiring Schematic</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/lab5schematic.jpg" class="img-fluid figure-img"></p>
<figcaption>Figure 5: Circuit Diagram</figcaption>
</figure>
</div>
<p>Above pictures the electrical circuit for our design. It portrays all electrical components used for the design. The design was pretty straightforward, just ensure to use the correct 5V input pins. Most of the pins on the STM32L432KC are only 3.3 logic input.</p>
</section>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The results of this lab were a success. The MC correctly recorded the rev/s of the motor for low and high speeds using interupts and timers. Two interupts were used for each edge of the encoder (A and B), and a timer was used for the 1/2 second delay for the display.</p>
</section>
<section id="interrupt-vs-polling" class="level2">
<h2 class="anchored" data-anchor-id="interrupt-vs-polling">Interrupt vs polling</h2>
<p>Before this lab I thought that polling would be a more efficient option compared to anything else. Polling is just something that I was used to when doing Systemverilog, or Python, however I think the difference between interrupts and polling is huge. To reinstate their overall differences:</p>
<p>Interrupts are a hardware-driven mechanism that temporarily pause the CPU’s current task to handle a specific event (such as a GPIO input change). Once the interrupt service routine (ISR) finishes executing, the CPU returns to its previous task. This approach can be more efficient because the CPU only reacts when needed, reducing unnecessary processing and potentially lowering power consumption.</p>
<p>Polling, in contrast, continuously checks the status of an input in a loop. The CPU repeatedly reads the GPIO pin and processes the data even if nothing has changed. This method is simpler to implement but uses more CPU time and power since the processor is always active and waiting for pins to go high or low.</p>
<p>Mathematically, their difference can be represented by the following:</p>
<p>To analyze polling for this lab, we consider reading a GPIO pin continuously and executing a conditional statement on each iteration. We also write this value. The example polling file can be seen below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/pollingc.png" class="img-fluid figure-img"></p>
<figcaption>Figure 6: Code for manual polling</figcaption>
</figure>
</div>
<p>To be able to tell how fast this polling occurs we need to seperate this code into instructions, then estimate how many cycles per instruction there are to be able to decide the overall frequency of the while loop. The assembly instruction for the code above can be found below. Given by SEGGER.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/pollingasse.png" class="img-fluid figure-img"></p>
<figcaption>Figure 7: Assembly instructions</figcaption>
</figure>
</div>
<p>Above is the general instructions for the code given. However it does not include the instructions for the called functions. Those, however WERE included in the calculation.</p>
<p>However we need to know how many individual cycles for each instruction we have so we can calculate how many instructions total. The link above in the Technical Documentation tab is from the ARM website for the CORTEX M-4. ARM, the designer for the CORTEX M-4 series, documented how many cycles for each instruction.</p>
<p>From this, we can calculate how many cycles our whole polling code takes.</p>
<p>This number comes out to around 97 cycles in the condition that each branch instr is 2 cycles, and that we did not include the delay_millis or the while (UIF).</p>
<p>Back to our earlier calculations, we find the frequency of polling using a CPU freq of 80 Mhz.</p>
<p>f = (CPU freq) / cycles -&gt; 824,742.268 Hz</p>
<p>With a period of:</p>
<p>t (latency) = 1/f -&gt; 1.21 μs</p>
<p>In the polling approach, the CPU executes the GPIO read loop continuously, using nearly 100% of processing time, even when no edges occur.</p>
<p>Comparing this to interrupt, the same steps were completed as before. Below is the assembly instructions used.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/assemint.png" class="img-fluid figure-img"></p>
<figcaption>Figure 8: Assembly for interrupt code</figcaption>
</figure>
</div>
<p>The cycles calculated were 57 cycles with 408 * 2 edges (we are only utilizing one encoder, but both edges) (We arent counting direction)</p>
<p>Each encoder edge triggers an interrupt, so the CPU only does work when an event occurs.</p>
<p>CPU time = (57 * 816) / CPU freq -&gt; 0.058 %</p>
<p>So interrupts only use 0.058% of CPU time when counting up to 1 full revolution, leaving the other 99.95% for other tasks.</p>
<p>The latency for the interrupts is 12 cycles which can be found here: <a href="https://hmc-e155.github.io/assets/doc/DDI0439B_cortex_m4_r0p0.pdf">Cortex-M4 Technical Reference Manual</a></p>
<p>The interrupt hardware latency, i.e., the time from the encoder edge to the first instruction of the ISR, is:</p>
<p>t (latency) = 12/ CPU freq = 0.15 μs</p>
<p>Thus, compared to polling, interrupts significantly reduce CPU usage while providing near-instantaneous response to encoder events.</p>
<p>At higher speeds the encoder can generate edges faster than the polling loop can check them. Thus, some edges may be missed because the CPU hasn’t completed the current loop iteration. However when running interrupts they are event-driven, so each encoder edge triggers the ISR immediately, regardless of overall motor speed.</p>
<p>Below is a summary table of the mathematical differences between the two.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/pollingvsint3.png" class="img-fluid figure-img"></p>
<figcaption>Figure 9: Summary Table</figcaption>
</figure>
</div>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The design was a success uploaded for this lab was a success. The STM32L432KC correctly took the input from the encoder, and provided speed and directional data. This lab was done using the CMSIS code provided by STM unlike lab 4. This made the code more structured and provided more readability for the reader.</p>
<p>This Lab took 8 hours.</p>
</section>
<section id="suggestions" class="level2">
<h2 class="anchored" data-anchor-id="suggestions">Suggestions</h2>
<p>Go through and understand each CMSIS file, and understand the stm32L4xxx header file.</p>
</section>
<section id="ai-prototype" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h2>
<p>This is the AI prototype for this lab. The prompt that was ran through Claude AI was:</p>
<p>Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?</p>
<p>The code that was produced as a result was :</p>
<p>/<em> </em> Quadrature Encoder Interface using TIM2 on STM32L432KC * Encoder connections: * Channel A -&gt; PA0 (TIM2_CH1) * Channel B -&gt; PA1 (TIM2_CH2) */</p>
<p>#include “stm32l4xx_hal.h”</p>
<p>TIM_HandleTypeDef htim2; volatile int32_t encoder_count = 0; volatile int32_t encoder_overflow = 0;</p>
<p>/* Initialize encoder interface */ void Encoder_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; TIM_Encoder_InitTypeDef sEncoderConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0};</p>
<pre><code>/* Enable clocks */
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_TIM2_CLK_ENABLE();

/* Configure GPIO pins PA0 and PA1 for TIM2 encoder input */
GPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);

/* Configure TIM2 in encoder mode */
htim2.Instance = TIM2;
htim2.Init.Prescaler = 0;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 0xFFFFFFFF;  // 32-bit counter
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

/* Encoder configuration: count on both edges of both channels */
sEncoderConfig.EncoderMode = TIM_ENCODERMODE_TI12;
sEncoderConfig.IC1Polarity = TIM_ICPOLARITY_RISING;
sEncoderConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;
sEncoderConfig.IC1Prescaler = TIM_ICPSC_DIV1;
sEncoderConfig.IC1Filter = 10;  // Input filtering
sEncoderConfig.IC2Polarity = TIM_ICPOLARITY_RISING;
sEncoderConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;
sEncoderConfig.IC2Prescaler = TIM_ICPSC_DIV1;
sEncoderConfig.IC2Filter = 10;

if (HAL_TIM_Encoder_Init(&amp;htim2, &amp;sEncoderConfig) != HAL_OK)
{
    Error_Handler();
}

sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&amp;htim2, &amp;sMasterConfig) != HAL_OK)
{
    Error_Handler();
}

/* Set counter to middle value to allow bidirectional counting */
__HAL_TIM_SET_COUNTER(&amp;htim2, 0x7FFFFFFF);

/* Enable update interrupt for overflow/underflow detection */
__HAL_TIM_ENABLE_IT(&amp;htim2, TIM_IT_UPDATE);

/* Configure NVIC */
HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(TIM2_IRQn);

/* Start encoder interface */
HAL_TIM_Encoder_Start(&amp;htim2, TIM_CHANNEL_ALL);</code></pre>
<p>}</p>
<p>/* TIM2 interrupt handler */ void TIM2_IRQHandler(void) { if (__HAL_TIM_GET_FLAG(&amp;htim2, TIM_FLAG_UPDATE) != RESET) { if (__HAL_TIM_GET_IT_SOURCE(&amp;htim2, TIM_IT_UPDATE) != RESET) { __HAL_TIM_CLEAR_IT(&amp;htim2, TIM_IT_UPDATE);</p>
<pre><code>        /* Check direction to determine overflow or underflow */
        if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&amp;htim2))
        {
            encoder_overflow--;  // Underflow
        }
        else
        {
            encoder_overflow++;  // Overflow
        }
    }
}</code></pre>
<p>}</p>
<p>/* Get current encoder position */ int32_t Encoder_GetCount(void) { int32_t cnt = (int32_t)(__HAL_TIM_GET_COUNTER(&amp;htim2)) - 0x7FFFFFFF; return cnt; }</p>
<p>/* Get absolute position including overflows */ int64_t Encoder_GetAbsoluteCount(void) { int32_t cnt = Encoder_GetCount(); int64_t total = ((int64_t)encoder_overflow &lt;&lt; 32) + cnt; return total; }</p>
<p>/* Reset encoder count */ void Encoder_Reset(void) { __HAL_TIM_SET_COUNTER(&amp;htim2, 0x7FFFFFFF); encoder_overflow = 0; }</p>
<p>/* Get encoder direction (1 = forward, -1 = reverse, 0 = stopped) */ int8_t Encoder_GetDirection(void) { if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&amp;htim2)) return -1; else return 1; }</p>
<p>/* Example usage in main */ int main(void) { HAL_Init(); SystemClock_Config();</p>
<pre><code>Encoder_Init();

while (1)
{
    int32_t position = Encoder_GetCount();
    int8_t direction = Encoder_GetDirection();
    
    // Use encoder data here
    HAL_Delay(10);
}</code></pre>
<p>}</p>
<p>/* Weak error handler - implement your own */ __weak void Error_Handler(void) { __disable_irq(); while (1) { } }</p>
<p>/* Weak system clock config - implement based on your setup */ __weak void SystemClock_Config(void) { // Configure your system clock here }</p>
<p>Related questions:</p>
<p>How would you rate the quality of the output and why?</p>
<p>I think the output produced is a little confusing. It has overall weird syntax that have not seen regarding the stm32Lxxx.h header. One example of this can be seen in ‘HAL_TIM_Encoder_Start(&amp;htim2, TIM_CHANNEL_ALL);’. Almost everywhere in the code i see the ‘HAL’ notation but i am quite unsure what this notation means.</p>
<p>Did the LLM generate any code for you? If so, how does it compare to your setup?</p>
<p>Like explained above, it uses irregular syntax from what I am used to. This caused me to be confused. This syntax might be correct however as I dont know the full extent to the stm32L4xxx header.</p>
<p>How does the LLM’s explanation compare to your reasoning for choosing your timer?</p>
<p>The same timer was chosen. This is just one of the basic overall timers used within the STM32.</p>
<p>Does the LLM work well as a sounding board, rather than a code generator as used in previous prototypes?</p>
<p>I think the LLM works well in giving you overall strcuture for the code and giving you the overall idea of what your code should generally look like. This can be important in fomrulating ideas, but is bad if you dont know where to look for the correct functions within the header file.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/Swayngee\.github\.io\/e155-lab1\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>