[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog posts",
    "section": "",
    "text": "Below are blog posts that consist of all my reflections within E155! I also included some class notes for clarity\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLab 0\n\n\nInitial reflection\n\n\n\n\n\nAug 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\nWeird software\n\n\n\n\n\nSep 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\n\n\n\nOct 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\n\n\n\nNov 27, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\n\n\n\n\n\n\nDec 1, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\n\n\n\n\n\n\nDec 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\n\n\n\n\n\n\nDec 3, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\n\n\n\n\n\n\nDec 4, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/projectproposal.html",
    "href": "project/projectproposal.html",
    "title": "Project Proposal: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "We will create a real-time 3-band equalizer (EQ) that can independently remove or boost lows, mids, and highs in an incoming audio signal. The system will feature three control knobs, one for each frequency range.\nThe project will accept audio through a standard 1/8-inch (3.5 mm) auxiliary input, allowing playback from a computer or mobile device. The analog audio signal will be digitized by an ADC, processed in real time by an FPGA using digital filtering, and then converted back to analog via a DAC for playback through a pair of speakers (left and right).\nThe design is going to be developed and implemented on an STM32L432KC Microcontroller, and an iCE40 UltraPlus FPGA.\n\n\n\n\n\nInput / Output:\nAudio is input via a 1/8-inch aux cable and output through a speaker in the digital lab.\nBypass Behavior:\nWhen all EQ knobs are in their default (neutral) positions, the output should closely match the original input audio.\nFrequency Bands:\nThe equalizer will feature three independently adjustable bands:\n\nLow band: ~100 Hz – 400 Hz\n\nMid band: ~400 Hz – 2 kHz\n\nHigh band: ~2 kHz – 8 kHz\n\nControl Interface:\nEach band will have its own potentiometer for analog gain adjustment (boost/cut).\nLatency:\nThe system will maintain real-time operation with &lt; 50 ms latency, ensuring audio remains synchronized with video sources such as YouTube.\nFiltering Performance:\nEach EQ band must correctly boost or attenuate its designated frequency range without introducing distortion or unintended interaction between bands. The correctness of filtering behavior will be verified through both frequency response measurements and subjective listening (ear tests).\nVerification:\nThe final report will include theoretical frequency responses for each band and confirm them via hardware measurements.\n\n\n\n\n\n\n\n\nPerform real-time IIR-based filtering for the three EQ bands.\nHandle I²S communication with both ADC and DAC devices.\nGenerate appropriate clock signals using internal oscillators (HSOSC or LFOSC).\n\n\n\n\n\nRead three analog potentiometer inputs (one per frequency band).\nCompute IIR filter coefficients based on knob positions.\nTransmit updated coefficients to the FPGA via SPI.\n\n\n\n\n\n\nConvert analog data to digital data\nCommunicate over I2S protocol\n\n\n\n\n\nConvert digital data to analog data\nCommunicate over I2S protocol\n\n\n\n\n\nEnd-to-end latency (ADC → FPGA processing → DAC) or buffering delays cause audible lag, clicking, or make the system unusable for live monitoring.\nMaking the ADC, DAC, MCU and FPGA clocks not synchronized\nIncreased quantization noise from using 16-bit data paths\nHigh-frequency content aliasing into the audio band if the ADC sample rate or analog filter are insufficient.\nIncorrect wiring between components\nOutput clipping at high volume damaging speakers or hearing.\nExceeding FPGA LUT’s, and more importantly, DSP slices\n\nOur FPGA Contains only 8 16x16 DSP slices, requiring clever pipelining and multiplexing to filter all signals in time\n\n\n\n\n\n\n\n\n\nComponent\nQuantity\nFunction\nInterface\nApprox. Cost\nNotes\n\n\n\n\nAdafruit PCM5102 I²S DAC\n1\nDigital-to-Analog Converter\nI²S\n~$6\n16–32 bit, 8–384 kHz sampling, 3.3V logic, 2.1 V-rms output\n\n\nPCM1808 ADC\n1\nAnalog-to-Digital Converter\nI²S\n~$6\n24-bit, 8–96 kHz sampling, 3.3–5V supply\n\n\nSTX-3000 Audio Jack\n1\nStereo audio input connector\nAnalog\n~$1\n3.5 mm TRS jack, through-hole and breadboard compatible\n\n\n3362 1/4-inch Square Trimpot Potentiometers\n3\nUser control for low, mid, and high bands\nAnalog\nStockroom\nReads by MCU ADC pins\n\n\nICE40 UltraPlus FPGA Board\n1\nReal-time DSP core\nI²C, SPI\nOn Hand\nPerforms all filtering\n\n\nSTM32L432KC MCU Board\n1\nUser interface and coefficient computation\nSPI, ADC\nOn Hand\nCommunicates with FPGA\n\n\nMiscellaneous Components\nn/a\nOp-amps, resistors, capacitors, wires\nAnalog\nStockroom\nUsed for signal conditioning, biasing, and connections\n\n\n\nSubtotal parts cost: ~$13 (excluding lab stock components).\nShipping and Taxes: ~$8\nTotal external parts cost: ~$21.\n\n\n\n\n\n\nFigure 1: Flow Chart of Partitioning and Connections.\n\n\n\n\nThe key performance characteristics of our EQ filter are defined by the sampling rate, ADC/DAC bit rate, and FPGA processing speed.\nSampling Rate / Nyquist:\nBy the Shannon–Nyquist theorem, the sampling frequency must exceed twice the highest signal frequency. Since the human ear can hear to around ~20 kHz, \\(f_s &gt; 40\\,\\text{kHz}\\).\nWe will use 48 kHz, providing a 24 kHz Nyquist limit and headroom for filtering.\nBit Rate:\nAt 48 kHz, 24 bits/sample, and stereo audio:\n\\[\nR = f_s \\times B \\times C = 48{,}000 \\times 24 \\times 2 \\approx 2.3\\,\\text{Mbps}\n\\]\nWith 32-bit I²S frames, the bit clock is approximately 3 MHz, easily handled by the FPGA.\nFPGA Throughput and Latency:\nAssuming a 48 kHz sample rate (sample period ≈ 20.83 µs), a 50 MHz fabric clock gives\n\\[\n\\frac{50\\ \\text{MHz}}{48\\ \\text{kHz}} \\approx 1042\n\\]\ncycles per sample, which is more than sufficient for three IIR filters using time-multiplexed multiplies. If the ADC and DAC run from the same sample clock and we complete filtering within one sample period, the per-sample processing latency is about 20.8 µs (\\(\\frac{1}{f_{ADC/DAC}}\\)). The ADC/DAC and any pipelining typically add only a few samples of delay (on the order of tens of microseconds). Even with conservative buffering, end-to-end latency remains ≪ 50 ms, easily meeting our real-time requirement.\nResolution / Noise:\n24-bit audio provides ~146 dB theoretical SNR; internal 32-bit accumulation will preserve precision and avoid quantization noise.\nOverall, the design easily meets real-time performance needs: 48 kHz sample rate, &lt;1 ms latency, and sufficient precision for transparent audio quality.\nLUT Usage\nBecause the filtering is duplicated, we duplicate the filtering hardware. The 3-band EQ consists of 3 cascading filters (low, mid, high), with each band using biquads. That means that we do \\(3 x 5 = 15\\) multiplies per sample. These are 16 bit multiples, and the FPGA has 8 16x16 DSP slices. That means that as long as we run the FPGA at least 1.875 times the sampling frequency of the ADC/DAC then we can fit in all the multiplies. For a sampling rate of 48 KHz, this will be easy as the FGPA can run on order of MHz.\n\n\n\nThe table below outlines the major project milestones, their target completion dates, and the team member responsible for leading each task. Tasks are ordered chronologically to ensure smooth integration of the hardware and firmware components leading up to a functional prototype.\n\n\n\nTask\nGoal Date\nLead Member\n\n\n\n\nOrder parts (after project approval)\nAs soon as approved\nDrake\n\n\nSuccessfully throughput unfiltered audio\n11/10\nDrake\n\n\nSuccessfully demo filtering in MATLAB\n11/10\nEoin\n\n\nSuccessfully measure potentiometer input on MCU\n11/17\nDrake\n\n\nFinish RTL design and verification via test benches\n11/17\nEoin\n\n\nComplete and test working prototype\n11/24\nWhole Team\n\n\n\nTask Division:\nDrake will primarily focus on the hardware integration side of the project, including part procurement, audio signal interfacing, and MCU testing. Eoin will lead the digital signal processing implementation, including MATLAB filter validation and FPGA RTL design with test benches. Both team members will collaborate closely in the final integration and prototype testing phase to ensure seamless hardware–software coordination and successful real-time operation.\nAs the project progresses, we will monitor our progress and reallocate tasks as needed to ensure balanced workloads and timely completion. Work will be tracked through a shared action-items spreadsheet. Additionally, we both aim to maintain a complete understanding of the entire system, ensuring that each of us can independently explain and reproduce every part of the project."
  },
  {
    "objectID": "project/projectproposal.html#project-proposal",
    "href": "project/projectproposal.html#project-proposal",
    "title": "Project Proposal: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "We will create a real-time 3-band equalizer (EQ) that can independently remove or boost lows, mids, and highs in an incoming audio signal. The system will feature three control knobs, one for each frequency range.\nThe project will accept audio through a standard 1/8-inch (3.5 mm) auxiliary input, allowing playback from a computer or mobile device. The analog audio signal will be digitized by an ADC, processed in real time by an FPGA using digital filtering, and then converted back to analog via a DAC for playback through a pair of speakers (left and right).\nThe design is going to be developed and implemented on an STM32L432KC Microcontroller, and an iCE40 UltraPlus FPGA.\n\n\n\n\n\nInput / Output:\nAudio is input via a 1/8-inch aux cable and output through a speaker in the digital lab.\nBypass Behavior:\nWhen all EQ knobs are in their default (neutral) positions, the output should closely match the original input audio.\nFrequency Bands:\nThe equalizer will feature three independently adjustable bands:\n\nLow band: ~100 Hz – 400 Hz\n\nMid band: ~400 Hz – 2 kHz\n\nHigh band: ~2 kHz – 8 kHz\n\nControl Interface:\nEach band will have its own potentiometer for analog gain adjustment (boost/cut).\nLatency:\nThe system will maintain real-time operation with &lt; 50 ms latency, ensuring audio remains synchronized with video sources such as YouTube.\nFiltering Performance:\nEach EQ band must correctly boost or attenuate its designated frequency range without introducing distortion or unintended interaction between bands. The correctness of filtering behavior will be verified through both frequency response measurements and subjective listening (ear tests).\nVerification:\nThe final report will include theoretical frequency responses for each band and confirm them via hardware measurements.\n\n\n\n\n\n\n\n\nPerform real-time IIR-based filtering for the three EQ bands.\nHandle I²S communication with both ADC and DAC devices.\nGenerate appropriate clock signals using internal oscillators (HSOSC or LFOSC).\n\n\n\n\n\nRead three analog potentiometer inputs (one per frequency band).\nCompute IIR filter coefficients based on knob positions.\nTransmit updated coefficients to the FPGA via SPI.\n\n\n\n\n\n\nConvert analog data to digital data\nCommunicate over I2S protocol\n\n\n\n\n\nConvert digital data to analog data\nCommunicate over I2S protocol\n\n\n\n\n\nEnd-to-end latency (ADC → FPGA processing → DAC) or buffering delays cause audible lag, clicking, or make the system unusable for live monitoring.\nMaking the ADC, DAC, MCU and FPGA clocks not synchronized\nIncreased quantization noise from using 16-bit data paths\nHigh-frequency content aliasing into the audio band if the ADC sample rate or analog filter are insufficient.\nIncorrect wiring between components\nOutput clipping at high volume damaging speakers or hearing.\nExceeding FPGA LUT’s, and more importantly, DSP slices\n\nOur FPGA Contains only 8 16x16 DSP slices, requiring clever pipelining and multiplexing to filter all signals in time\n\n\n\n\n\n\n\n\n\nComponent\nQuantity\nFunction\nInterface\nApprox. Cost\nNotes\n\n\n\n\nAdafruit PCM5102 I²S DAC\n1\nDigital-to-Analog Converter\nI²S\n~$6\n16–32 bit, 8–384 kHz sampling, 3.3V logic, 2.1 V-rms output\n\n\nPCM1808 ADC\n1\nAnalog-to-Digital Converter\nI²S\n~$6\n24-bit, 8–96 kHz sampling, 3.3–5V supply\n\n\nSTX-3000 Audio Jack\n1\nStereo audio input connector\nAnalog\n~$1\n3.5 mm TRS jack, through-hole and breadboard compatible\n\n\n3362 1/4-inch Square Trimpot Potentiometers\n3\nUser control for low, mid, and high bands\nAnalog\nStockroom\nReads by MCU ADC pins\n\n\nICE40 UltraPlus FPGA Board\n1\nReal-time DSP core\nI²C, SPI\nOn Hand\nPerforms all filtering\n\n\nSTM32L432KC MCU Board\n1\nUser interface and coefficient computation\nSPI, ADC\nOn Hand\nCommunicates with FPGA\n\n\nMiscellaneous Components\nn/a\nOp-amps, resistors, capacitors, wires\nAnalog\nStockroom\nUsed for signal conditioning, biasing, and connections\n\n\n\nSubtotal parts cost: ~$13 (excluding lab stock components).\nShipping and Taxes: ~$8\nTotal external parts cost: ~$21.\n\n\n\n\n\n\nFigure 1: Flow Chart of Partitioning and Connections.\n\n\n\n\nThe key performance characteristics of our EQ filter are defined by the sampling rate, ADC/DAC bit rate, and FPGA processing speed.\nSampling Rate / Nyquist:\nBy the Shannon–Nyquist theorem, the sampling frequency must exceed twice the highest signal frequency. Since the human ear can hear to around ~20 kHz, \\(f_s &gt; 40\\,\\text{kHz}\\).\nWe will use 48 kHz, providing a 24 kHz Nyquist limit and headroom for filtering.\nBit Rate:\nAt 48 kHz, 24 bits/sample, and stereo audio:\n\\[\nR = f_s \\times B \\times C = 48{,}000 \\times 24 \\times 2 \\approx 2.3\\,\\text{Mbps}\n\\]\nWith 32-bit I²S frames, the bit clock is approximately 3 MHz, easily handled by the FPGA.\nFPGA Throughput and Latency:\nAssuming a 48 kHz sample rate (sample period ≈ 20.83 µs), a 50 MHz fabric clock gives\n\\[\n\\frac{50\\ \\text{MHz}}{48\\ \\text{kHz}} \\approx 1042\n\\]\ncycles per sample, which is more than sufficient for three IIR filters using time-multiplexed multiplies. If the ADC and DAC run from the same sample clock and we complete filtering within one sample period, the per-sample processing latency is about 20.8 µs (\\(\\frac{1}{f_{ADC/DAC}}\\)). The ADC/DAC and any pipelining typically add only a few samples of delay (on the order of tens of microseconds). Even with conservative buffering, end-to-end latency remains ≪ 50 ms, easily meeting our real-time requirement.\nResolution / Noise:\n24-bit audio provides ~146 dB theoretical SNR; internal 32-bit accumulation will preserve precision and avoid quantization noise.\nOverall, the design easily meets real-time performance needs: 48 kHz sample rate, &lt;1 ms latency, and sufficient precision for transparent audio quality.\nLUT Usage\nBecause the filtering is duplicated, we duplicate the filtering hardware. The 3-band EQ consists of 3 cascading filters (low, mid, high), with each band using biquads. That means that we do \\(3 x 5 = 15\\) multiplies per sample. These are 16 bit multiples, and the FPGA has 8 16x16 DSP slices. That means that as long as we run the FPGA at least 1.875 times the sampling frequency of the ADC/DAC then we can fit in all the multiplies. For a sampling rate of 48 KHz, this will be easy as the FGPA can run on order of MHz.\n\n\n\nThe table below outlines the major project milestones, their target completion dates, and the team member responsible for leading each task. Tasks are ordered chronologically to ensure smooth integration of the hardware and firmware components leading up to a functional prototype.\n\n\n\nTask\nGoal Date\nLead Member\n\n\n\n\nOrder parts (after project approval)\nAs soon as approved\nDrake\n\n\nSuccessfully throughput unfiltered audio\n11/10\nDrake\n\n\nSuccessfully demo filtering in MATLAB\n11/10\nEoin\n\n\nSuccessfully measure potentiometer input on MCU\n11/17\nDrake\n\n\nFinish RTL design and verification via test benches\n11/17\nEoin\n\n\nComplete and test working prototype\n11/24\nWhole Team\n\n\n\nTask Division:\nDrake will primarily focus on the hardware integration side of the project, including part procurement, audio signal interfacing, and MCU testing. Eoin will lead the digital signal processing implementation, including MATLAB filter validation and FPGA RTL design with test benches. Both team members will collaborate closely in the final integration and prototype testing phase to ensure seamless hardware–software coordination and successful real-time operation.\nAs the project progresses, we will monitor our progress and reallocate tasks as needed to ensure balanced workloads and timely completion. Work will be tracked through a shared action-items spreadsheet. Additionally, we both aim to maintain a complete understanding of the entire system, ensuring that each of us can independently explain and reproduce every part of the project."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 1 - A familiarization of Micro-controller units (MCU’s) and field-programmable gate arrays (FPGA’s)\n\n\n\n\n\n\n\n\nSep 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2 - Multiplexed 7-segment display\n\n\n\n\n\n\n\n\nSep 8, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3 - Keypad Scanner\n\n\n\n\n\n\n\n\nSep 22, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4 Digital Audio\n\n\n\n\n\n\n\n\nSep 30, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5 Interrupts\n\n\n\n\n\n\n\n\nOct 6, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6 - The Internet of Things and Serial Peripheral Interface\n\n\n\n\n\n\n\n\nOct 15, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7 - The Advanced Encryption Standard (AES)\n\n\n\n\n\n\n\n\nNov 3, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Lab 0",
    "section": "",
    "text": "Throughout my tenure at Harvey Mudd College I have taken many classes within the engineering discipline. Most of these classes, although cool, had little to do with what I was actually passionate about, which is lithography. Lithography is a process within the chip-making industry, that etches computer chips onto silicon wafers. This process, although existing for many decades, still feels like magic to me, which is the reason I am so passionate about it.\nWithin E155 I would like to further my knowledge of computer engineering and really start grasping how micro-controllers work. Micro-controllers make up the digital world as we know it, and I want to learn how they have a specific impact in Lithography."
  },
  {
    "objectID": "labs/lab4.html#introduction",
    "href": "labs/lab4.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a design was made to use a microcontroller, its respective timers, clk and GPIO pins, to play music. Two timers were incorporated into this design. TIM16 was used as a PWM source to create an output square wave, and TIM7 was used as a delay timer. The clk used for the TIM16 design was the PLL, which was initialized by the MSI (4MHZ). For TIM7, the MSI(4Hz) clk was used in a direct connection.\nThe design was developed using C on SEGGER, and implemented on an STM32L432KC Microcontroller."
  },
  {
    "objectID": "labs/lab4.html#technical-documentation",
    "href": "labs/lab4.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\nThe documentation for the STM32L432KC manual Github link.\n\nEquations\nTo be able to control the timer’s correctly, the design implemented sets internal prescalars which slows down the clock to be able to control the output minimum and maximum, frequency and duration.\nTo perform this function, the design must first set the correct internal oscillator on, in this case it was the MSI clk. This clock oscillates at 4 MHz.\nTo step down this clk for the wide range of frequency’s (0 to ~1500 Hz) and duration (0 to 500 ms) for this lab a correct prescalar must be set for each timer.\n\nTIM7 - delay timer\nFor timer7 (a basic timer), a prescaler of 39 was chosen to stepdown the MSI clk to 100 kHz. To calculate the minimum duration we take the clock rate that we dropped to 100kHz, and invert it to find the time. 1/100Khz = 10 µs per count. We then use the equation 100*ms - 1; to determine our ARR value.\nMinimum delay - The input frequency must be above 1 to prevent the underflow of bits. (100 * (0)-1) = -1. Maximum delay - The input frequency must be below the max value from our ARR * 100, which is m &lt;= 655.36ms.\n\n\nTIM16 - PWM timer\nFor timer16 (a General-Purpose timer), a prescalar value of 3 was chosen to stepdown the PLL input clock to 1Mhz. Maximum freq - 1Mhz, which is out input frequency, although this value will unlikely sound. Minimum freq - Fmin = 1,000,000/ 65536 (the highest ARR) = 15.258789 Hz\n\nFor 1% spec:\nThe formula is:\ninput frq clkfreq = 1,000,000 tickperiod = psc/clkfreq\nARR -&gt; (clkfreq/((psc+1)*frq))-1\nT -&gt; ARR * tickperiod\nf(output) = 1/T\nTo calculate the 1% spec I ran a frequency through my equation, and found the output frequency. Each of which were within the 1% frequency spec.\n\n\n\nFigure 1: This schematic shows the wiring and components between our dev board, the 7-segment display, and the keypad.\n\n\nAbove is a spreadsheet representation of the inputs and outputs of my equation.\nTo verify such we test on an oscilliscope:\n\n\n\nFigure 2: This schematic shows the wiring and components between our dev board, the 7-segment display, and the keypad.\n\n\nAbove in the left hand bottom corner you can see the measured frequency is 263Hz. This occured at the 11th cord, which was 264Hz. This measured frequency is 1% of the actual frequency.\nWiring Schematic\n\n\n\nFigure 3: This schematic shows the wiring and components between our dev board, the 7-segment display, and the keypad.\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design."
  },
  {
    "objectID": "labs/lab4.html#results-and-discussion",
    "href": "labs/lab4.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nTo find each step to configure each timer and its respective registers, the STM32L432 reference manual was used.\nThe steps taken for this lab were:\nCreate pointers for each register inside each timer Initialize TIM16 and configure the PWM mode Link TIM6 to the MSI, and create a counter-up delay Combine these functions and run them inside the main file.\nAn example of one of these steps from the datasheet can be seen below.\n\n\n\nFigure 4: PWM mode for TIM16\n\n\nAbove is sections 28.510 of the reference manual. It describes how to set up the TIM15 and TIM16 PWM mode by showing what registers to enable or what bits to put in different registers.\nThe design uploaded to the STM32 was a success. It sucessfully produced Fur Elise, and another composition of my choice, which was te first few initial chrods of Thunderstruck by AC/DC."
  },
  {
    "objectID": "labs/lab4.html#conclusion",
    "href": "labs/lab4.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was a success. Each note was played at the correct frequency (measured by the oscilliscope), and correctly delayed each PWM signal by the amount specified. Each notes volume was also controlled by a potentiometer. A seperate composition was created and worked as intended as well. This lab taught the importance of datasheets, registers, bit-wise functions, and header files. That being said it also taught the importance of knowing which CMSIS folders to use when using a new microcontroller.\nThis Lab took 15 hours."
  },
  {
    "objectID": "labs/lab4.html#suggestions",
    "href": "labs/lab4.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nTo, in future labs, better understand the differences in each clock, and understand what the benefits of using each other are. I also want to better understand the specific hardware that drives these clocks."
  },
  {
    "objectID": "labs/lab4.html#ai-prototype",
    "href": "labs/lab4.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai prototype",
    "text": "Ai prototype\nHere is the AI prototype for this lab. Posted below is the prompt that was plugged into Claude AI:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nThe output (part):\nWhy TIM2 is Optimal TIM2 is a 32-bit general-purpose timer that offers several advantages:\nPWM output capability - can directly drive GPIO pins 32-bit resolution - provides fine frequency control Multiple output channels - TIM2_CH1 through TIM2_CH4 Easy GPIO connection - dedicated timer output pins\nBasic Configuration Sequence\nEnable timer clock in RCC_APB1ENR1 Configure GPIO for alternate function (AF1 for TIM2) Set prescaler and auto-reload values Configure PWM mode in CCMRx register Enable channel output in CCER register Set duty cycle in CCRx register Start timer by setting CEN bit\nThe Ai wanted me to use the TIM2 timer which is a good timer to use for the PWM output. It then gave me steps on how to set it up using the correct registers from the manul. The output from the model did not change when I also uploaded the reference manual for reference. However, the output did get more specific and gave me more direct code for the design:\n// Enable GPIOA clock RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n// Configure PA0 as alternate function (TIM2_CH1) GPIOA-&gt;MODER &= ~(0x3 &lt;&lt; 0); GPIOA-&gt;MODER |= (0x2 &lt;&lt; 0); // Alternate function mode\n// Set alternate function 1 for TIM2 GPIOA-&gt;AFR[0] &= ~(0xF &lt;&lt; 0); GPIOA-&gt;AFR[0] |= (0x1 &lt;&lt; 0); // AF1 for TIM2\nOverall this LLM was super fast (took about 5s to respond), andd it gave an accurate answer when it comes to specific registers and bit-wise functions. The LLM also generated code for the GPIO pins, which was very similar to the GPIO header file that was provided this lab. TIM 15 and 16 are the timers that I used due to them being more versatile in future designs. Overall, I belive the LLM did excellent in C and microcontroller design."
  },
  {
    "objectID": "labs/lab7.html#introduction",
    "href": "labs/lab7.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a design was made to use a microcontroller and an FPGA to implement the Advanced Encrypton Standard (AES). AES is a complicated method in which a message is encrypted and decrypted in a non-linear way. This is done such that messages/ communication as a whole can be done in secret. This standard has two inputs, a key, and a plaintext message, and outputs a done signal and a encrpted message. In this lab only the encryption was done, but the decryption can be done by completing the steps in opposite order. These steps include keyexpansion, switching the rows of the encryption message matrix, mixing the columns, and mixing in they expanded key every round. This standard is very complicating when it comes to ensuring clock signals line up, and inputs/outputs/enablers work as intended.\nThe design was developed using C on SEGGER, and implemented on an STM32L432KC Microcontroller."
  },
  {
    "objectID": "labs/lab7.html#technical-documentation",
    "href": "labs/lab7.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\nThe documentation for the STM32L432KC manual Github link.\nThe documentation for the AES Github link."
  },
  {
    "objectID": "labs/lab7.html#equations",
    "href": "labs/lab7.html#equations",
    "title": "E155 portfolio",
    "section": "Equations",
    "text": "Equations\nThere were no equations used for this lab."
  },
  {
    "objectID": "labs/lab7.html#testbenches",
    "href": "labs/lab7.html#testbenches",
    "title": "E155 portfolio",
    "section": "Testbenches",
    "text": "Testbenches\nBelow are the testbecnhes completed for the core, and SPI modules for this design. These modules acted like a ‘top’ module for our design and tested the two sections within our design. The core represented the code written for the AES implementation and the Spi was the communication protocol used between the FPGA and the MC. Below is the core testbench:\n\n\n\nFigure 1: Testbench showing all states / inputs and outputs of each state from the core module\n\n\nAbove portrays the Inputs and outputs from the fsm for the core module.\n\n\n\nFigure 2: Testbench showing the output from the core module\n\n\nAbove is the expected and the actual values coming out from our Core module. This verified that our AES implementation was correct. The testbench was condensed to this version to compare results only.\n\n\n\nFigure 3: SPI testbench showing expected vs actual values\n\n\nAbove is the SPI testbench for lab 7. It shows the expected vs the actual and other signals useful for the transaction.\n\n\n\nFigure 4: Testbench for the subbytes module\n\n\nAbove is the testbench for the subbytes module."
  },
  {
    "objectID": "labs/lab7.html#finite-state-machines-fsm",
    "href": "labs/lab7.html#finite-state-machines-fsm",
    "title": "E155 portfolio",
    "section": "Finite State Machines (FSM)",
    "text": "Finite State Machines (FSM)\n\n\n\nFigure 6: Schematic for the keyexpansion fsm\n\n\n\n\n\nFigure 7: Schematic for the aesrounds fsm"
  },
  {
    "objectID": "labs/lab7.html#wiring-schematic",
    "href": "labs/lab7.html#wiring-schematic",
    "title": "E155 portfolio",
    "section": "Wiring Schematic",
    "text": "Wiring Schematic\n\n\n\nFigure 6: This schematic shows the wiring and components between our dev board, the ESP8266, the DS1722, and the onboard LED\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design."
  },
  {
    "objectID": "labs/lab7.html#results-and-discussion",
    "href": "labs/lab7.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nLogic Analyzer\nFor this lab, a website was created to be able to toggle an LED on and off, and control the resolution of a tempertaure sensor, the output of the seen can be seen below.\n\n\n\nFigure 4: Below is an example of the output from the website"
  },
  {
    "objectID": "labs/lab7.html#conclusion",
    "href": "labs/lab7.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was a success. The microcontroller successfully was linked to the FPGA via SPI protocol, and the Advances Encryption Standard was implemented. I correctly wrote systemverilog to create the AES, and completed testbenches to test my design. The result was also correctly recorded on an logic analyzer.\nThis Lab took 45 hours."
  },
  {
    "objectID": "labs/lab7.html#suggestions",
    "href": "labs/lab7.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nTo better manage time when completing such a hard module. I spent a whole lot of time just writing the code at first, but I shouldve gone through each module, tested it, then gone to the next to ensure proper flow. Then in the top module just ensure/fix the timing results."
  },
  {
    "objectID": "labs/lab7.html#ai-prototype",
    "href": "labs/lab7.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai Prototype",
    "text": "Ai Prototype\nThis AI prototype was used with Claude, a code based AI. The first prompt can be seen below:\nWrite SystemVerilog HDL to implement the KeyExpansion logic described in the FIPS-197 uploaded document. The module should be purely combinational, using the previous key and current round number to calculate the next key. Assume other required modules (SubWord and RotWord) are already implemented.\nThe output from the prompt:"
  },
  {
    "objectID": "labs/lab2.html#introduction",
    "href": "labs/lab2.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a time-multiplexing scheme was made to drive two 7-segment display using single set of FPGA I/O pins. Time multiplexing is a technique in computer hardware that basically allows the use to use multiple purposes of a specific hardware at different times. In the case of this lab, time-multiplexing is used by displaying hexidecimal digits on the 7-segement display. The catch is, the display has two digital displays, but is controled by only one set of FPGA pins. Since both digits cannot be displayed at the same time, each digit is flickered to the point to where it appears each are both on at the same time. While this display is in place, five leds on a breadboard will display the addition of the hexadecimal digits displayed.\nThe design was developed using SystemVerilog, a hardware description language, and was tested using Intels Questa, a logic waveform simulator."
  },
  {
    "objectID": "labs/lab2.html#technical-documentation",
    "href": "labs/lab2.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\n\nEquations\nTo be able to solve for the correct clock cycles to correctly see both digits, first use a frequency in which the human cannot see flickering. This was guessed at around 240 Hz. Then do 1/F to get time = 0.00416 seconds. Then divide this by 2 to get 1 toggle (on), which is 0.002083 seconds. Finally, to solve for amount of cycles the equation is N = t(toggle)* frequency(clk). Solving for this, N comes out to be 100,000 cycles. Note** For testing of the HSOSC I used a frequency of 2.4 Mhz to be able to see the displays clearly toggling in the simulation.\nTo find the current at the transistor we first find the Base-Emitter Saturation Voltage, which is ~0.70. We then use V=IR in which V = (3.3V - 0.70V) and R = 1kΩ. We then divide 2.6V / 1kΩ to get current. Our current comes out to be 2.6mA which is an acceptable current and it worked when implemented. For reference, the I/O pins can take in a current of around 8mA.\nThirdly, to find the overall input current for the 7-segment display, the formula V-Vf-Vs-IR=0 was used. The knowns for this equation are Vin, which is 3.3V, Vf, which is around 1.9V, Vs which is 0.25 (the Collector-Emmiter saturation), and the resistance used was 1kΩ based on how bright the light was. Using this, the current comes out to 1.15 mA, which is an acceptable current.\nLastly, for the leds we use current-limiting resistors. To solve for the current we use the same formula from above in which V-Vd-IR=0. The input current is 3.3V, Vf is around 2.1V. The amps at this vf is around 4mA. This amounts to around 300Ω. For this resistor I chose 330Ω.\nBlock Diagram\n\n\n\nFigure 1: This block diagram shows the connection between the FPGA, its inside hardware, and LEDs used in Lab 2.\n\n\nThe block diagram above hosts the FPGA, a mux, a HSOSC module, and an output for the LED adder module. The input to this whole system is two input switches, s1 and s2, and three outputs, which were the display output, the binary 7-segment output, and the five Led adder output.\nWiring Schematic\n\n\n\nFigure 2: This schematic shows the wiring and components between our dev board, the 7-segment display, and our Led’s\n\n\nFigure 2 above pictures the electrical circuit related to the FPGA and the 7-segment display. It portrays both modules along with the pins used for each module, and the necessary switches, LED’s, pull down resistors, and transistors needed."
  },
  {
    "objectID": "labs/lab2.html#results-and-discussion",
    "href": "labs/lab2.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design implemented onto the FPGA met the primary objective of this lab, which was to display two hexadecimal digits on a two-sided 7-segment display and control five LED’s for an adder. This design was succsessfull in the way it that each Hexadecimal digits were clearly displayed at the ‘same time’, and the sum of these numbers was displayed on our led[4:0]. Furthermore, each segment on the 7-segment display appeared the same brightness, which suggests that the transistors and other electrical components worked as intended, and the sum of our numbers from the adder was correct.\n\nTestbench Simulation\nThe following simulations were run on Intel’s Questa. This was done to visually see the waveforms created as a result of the logic used. To complete this simulation, a testbench was created to run test vectors through the logic created. Each testbench below was written different.\nFor the 7-segment design, a testvector file was created to run through all possible switch inputs and outputs to our 7-segment display.\nSecondly, for the adder design, a for loop was created to run through all 256 possible testvectors possible. On the rising edge of the clock each testvector is ran through our .sv file, while on the falling edge, a test is ran to ensure that the sum is the expected value.\nThirdly, for our mux design, it displayed the same idea as the adder design, however there was no addition going into the for loop, and it checked if our enabler worked correctly.\nFinally, our top design held three test, each with different switch combinations, that tested whether the outputs match our expected outputs after it is ran through our module files.\n7-segment Display Simulation\n\n\n\nFigure 3: Above pictures the waveforms corresponding to the combinational logic used for the 7-segment display\n\n\nAbove is waveform simulation for the the 7-segment display design. This design was purely combinational logic, and hosts a clk and reset. This simulation was a success due to seg matching segexpected.\nLED Display Simulation\n\n\n\nFigure 4: Above pictures the waveforms corresponding to the logic used for flashing Led[4:0]\n\n\nFigure 4 shows the successfull simulation coming from the LED adder. The decimal values stemming from led and ledexpected are the same which shows that the leds will display the same behavior when connected to our FPGA.\nMux Simulation \nFigure 5 shows the simulation of the mux that has inputs of switches and the enabler. This simulation was a success based upon the fact that the output [mux] chnages based on which disp output was high.\nTop Module Simulation\n\n\n\nFigure 6: Above pictures the waveforms corresponding to the top module\n\n\nAbove is the top module design for the lab. It hosts inputs of reset and switches, and has outputs displ, led[4:0], seg[6:0]. To test the clock divider, a 2.5Mhz frequency was ran through the simulation. To test if this was done correct, we check if each of the sub-modules were performed correctly, then checked if, on the rising and falling edge of the clock, the clock divider changed, along with the disp, and mux outputs."
  },
  {
    "objectID": "labs/lab2.html#conclusion",
    "href": "labs/lab2.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design created was a successs. With each segment on the 7-segment display illuminating at the correct frequency, each transistor operating as intended, each led adding correctly, and each switch wired correctly. This lab was completed in 8 hours."
  },
  {
    "objectID": "labs/lab2.html#suggestions",
    "href": "labs/lab2.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nWhen first creating the modular design, keep the HSOSC at the top module level such that overall module testing is easier. Use a clk to test the HSOSC for a set frequency to be able to see correct toggling."
  },
  {
    "objectID": "labs/lab2.html#ai-prototype",
    "href": "labs/lab2.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai prototype",
    "text": "Ai prototype\n\nBelow is the output from Claude Ai after running this prompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n// Time Multiplexed Seven Segment Decoder // Multiplexes a single decoder to drive two common anode displays\nmodule seven_seg_mux ( input logic clk, input logic rst_n, input logic [3:0] digit0_in, // First 4-bit input input logic [3:0] digit1_in, // Second 4-bit input output logic [6:0] seg0_out, // Seven segments for display 0 (active low) output logic [6:0] seg1_out, // Seven segments for display 1 (active low) output logic [1:0] display_sel // Display selection for external digit enable );\n// Internal signals\nlogic [3:0] mux_input;\nlogic [6:0] decoder_output;\nlogic mux_sel;\nlogic [15:0] counter;  // Counter for time multiplexing\n\n// Counter for generating multiplex timing\n// Adjust counter width and compare value for desired refresh rate\nalways_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        counter &lt;= 16'h0;\n    else\n        counter &lt;= counter + 1;\nend\n\n// Generate multiplex select signal\n// Toggle every 2^15 clock cycles (adjust as needed)\nassign mux_sel = counter[15];\nassign display_sel = {~mux_sel, mux_sel}; // One-hot display enable\n\n// Input multiplexer\nalways_comb begin\n    case (mux_sel)\n        1'b0: mux_input = digit0_in;\n        1'b1: mux_input = digit1_in;\n    endcase\nend\n\n// Seven segment decoder (common anode - active low outputs)\nalways_comb begin\n    case (mux_input)\n        4'h0: decoder_output = 7'b1000000; // 0\n        4'h1: decoder_output = 7'b1111001; // 1\n        4'h2: decoder_output = 7'b0100100; // 2\n        4'h3: decoder_output = 7'b0110000; // 3\n        4'h4: decoder_output = 7'b0011001; // 4\n        4'h5: decoder_output = 7'b0010010; // 5\n        4'h6: decoder_output = 7'b0000010; // 6\n        4'h7: decoder_output = 7'b1111000; // 7\n        4'h8: decoder_output = 7'b0000000; // 8\n        4'h9: decoder_output = 7'b0010000; // 9\n        4'hA: decoder_output = 7'b0001000; // A\n        4'hB: decoder_output = 7'b0000011; // b\n        4'hC: decoder_output = 7'b1000110; // C\n        4'hD: decoder_output = 7'b0100001; // d\n        4'hE: decoder_output = 7'b0000110; // E\n        4'hF: decoder_output = 7'b0001110; // F\n    endcase\nend\n\n// Output demultiplexer - route decoder output to appropriate display\nalways_comb begin\n    if (mux_sel == 1'b0) begin\n        seg0_out = decoder_output;\n        seg1_out = 7'b1111111;  // All segments off (active low)\n    end else begin\n        seg0_out = 7'b1111111;  // All segments off (active low)\n        seg1_out = decoder_output;\n    end\nend\nendmodule\n// Testbench module seven_seg_mux_tb; logic clk; logic rst_n; logic [3:0] digit0_in; logic [3:0] digit1_in; logic [6:0] seg0_out; logic [6:0] seg1_out; logic [1:0] display_sel;\n// Instantiate DUT\nseven_seg_mux dut (\n    .clk(clk),\n    .rst_n(rst_n),\n    .digit0_in(digit0_in),\n    .digit1_in(digit1_in),\n    .seg0_out(seg0_out),\n    .seg1_out(seg1_out),\n    .display_sel(display_sel)\n);\n\n// Clock generation\ninitial begin\n    clk = 0;\n    forever #5 clk = ~clk;  // 100MHz clock\nend\n\n// Test stimulus\ninitial begin\n    // Initialize\n    rst_n = 0;\n    digit0_in = 4'h0;\n    digit1_in = 4'h0;\n    \n    // Reset release\n    #20 rst_n = 1;\n    \n    // Test different digit combinations\n    #100 digit0_in = 4'h5; digit1_in = 4'hA;\n    #100 digit0_in = 4'h3; digit1_in = 4'h7;\n    #100 digit0_in = 4'h9; digit1_in = 4'hF;\n    \n    // Run for several multiplex cycles\n    #1000000;\n    \n    $finish;\nend\n\n// Monitor outputs\ninitial begin\n    $monitor(\"Time=%0t, mux_sel=%b, digit0=%h, digit1=%h, seg0=%b, seg1=%b, disp_sel=%b\",\n             $time, dut.mux_sel, digit0_in, digit1_in, seg0_out, seg1_out, display_sel);\nend\nendmodule\n\n\nAfter this was created, another prompt was ran through claude: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n// Time Multiplexed Seven Segment Decoder // Uses existing lab2_dg_seg decoder and HSOSC oscillator // Multiplexes between two 4-bit inputs to drive two separate 7-segment outputs\nmodule time_mux_seven_seg ( input logic reset, input logic [3:0] digit0_in, // First 4-bit input input logic [3:0] digit1_in, // Second 4-bit input output logic [6:0] seg0_out, // Seven segments for display 0 output logic [6:0] seg1_out, // Seven segments for display 1 output logic disp0_en, // Display 0 enable (active high) output logic disp1_en // Display 1 enable (active high) );\n// Internal signals\nlogic int_osc;                  // Internal oscillator\nlogic [3:0] mux_input;          // Multiplexed input to decoder\nlogic [6:0] decoder_output;     // Output from seven segment decoder\nlogic enabler;                  // Multiplex control signal\nlogic [20:0] counter;           // Counter for timing\n\n// Internal oscillator instantiation (same as in lab2_dg_top)\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(int_osc));\n\n// Clock divider and multiplex control (similar to lab2_dg_top)\nalways_ff @(posedge int_osc) begin\n    if (~reset) begin\n        counter &lt;= 21'b0;\n        enabler &lt;= 1'b0;\n    end else begin\n        if (counter == 21'd100000) begin  // Adjust for desired refresh rate\n            enabler &lt;= ~enabler; \n            counter &lt;= 21'b0;\n        end\n        else \n            counter &lt;= counter + 21'd1;\n    end\nend\n\n// Input multiplexer (based on lab2_dg_mux logic)\nalways_comb begin\n    if (enabler == 1'b0) begin\n        disp0_en = 1'b1;\n        disp1_en = 1'b0;\n        mux_input = digit0_in;\n    end\n    else begin\n        disp0_en = 1'b0;\n        disp1_en = 1'b1;\n        mux_input = digit1_in;\n    end \nend\n\n// Instantiate existing seven segment decoder\nlab2_dg_seg u_seg (\n    .mux(mux_input),\n    .seg(decoder_output)\n);\n\n// Output demultiplexer - route decoder output to appropriate display\n// Turn off inactive display (all segments high for common anode)\nalways_comb begin\n    if (enabler == 1'b0) begin\n        seg0_out = decoder_output;\n        seg1_out = 7'b1111111;  // All segments off (common anode)\n    end else begin\n        seg0_out = 7'b1111111;  // All segments off (common anode)\n        seg1_out = decoder_output;\n    end\nend\nendmodule\n// Testbench for the time multiplexed seven segment decoder module time_mux_seven_seg_tb(); logic reset; logic [3:0] digit0_in; logic [3:0] digit1_in; logic [6:0] seg0_out; logic [6:0] seg1_out; logic disp0_en; logic disp1_en; logic [31:0] errors;\n// Instantiate DUT\ntime_mux_seven_seg dut (\n    .reset(reset),\n    .digit0_in(digit0_in),\n    .digit1_in(digit1_in),\n    .seg0_out(seg0_out),\n    .seg1_out(seg1_out),\n    .disp0_en(disp0_en),\n    .disp1_en(disp1_en)\n);\n\n// Test stimulus\ninitial begin\n    errors = 0;\n    \n    // Initialize\n    reset = 0;\n    digit0_in = 4'h0;\n    digit1_in = 4'h0;\n    \n    // Reset release\n    #22 reset = 1;\n    \n    // Test case 1: Display 3 and 2\n    digit0_in = 4'h3;\n    digit1_in = 4'h2;\n    $display(\"Test 1: digit0=3, digit1=2\");\n    \n    // Wait for several multiplex cycles and check outputs\n    repeat(10) begin\n        // Wait for display 0 to be active\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0110000 || seg1_out != 7'b1111111) begin  // 3 on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit 3 failed\");\n        end else begin\n            $display(\"Display 0 correctly showing 3\");\n        end\n        \n        // Wait for display 1 to be active  \n        wait(!disp0_en && disp1_en);\n        #10;\n        if (seg1_out != 7'b0100100 || seg0_out != 7'b1111111) begin  // 2 on display 1\n            errors++;\n            $display(\"Error: Display 1 showing digit 2 failed\");\n        end else begin\n            $display(\"Display 1 correctly showing 2\");\n        end\n    end\n    \n    // Test case 2: Display A and F\n    digit0_in = 4'hA;\n    digit1_in = 4'hF;\n    $display(\"Test 2: digit0=A, digit1=F\");\n    \n    // Wait and check again\n    repeat(5) begin\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0001000) begin  // A on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit A failed\");\n        end else begin\n            $display(\"Display 0 correctly showing A\");\n        end\n        \n        wait(!disp0_en && disp1_en);\n        #10; \n        if (seg1_out != 7'b0001110) begin  // F on display 1\n            errors++;\n            $display(\"Error: Display 1 showing digit F failed\");\n        end else begin\n            $display(\"Display 1 correctly showing F\");\n        end\n    end\n    \n    // Test case 3: Same digits on both displays\n    digit0_in = 4'h8;\n    digit1_in = 4'h8;\n    $display(\"Test 3: Both displays showing 8\");\n    \n    repeat(3) begin\n        wait(disp0_en && !disp1_en);\n        #10;\n        if (seg0_out != 7'b0000000) begin  // 8 on display 0\n            errors++;\n            $display(\"Error: Display 0 showing digit 8 failed\");\n        end\n        \n        wait(!disp0_en && disp1_en);\n        #10;\n        if (seg1_out != 7'b0000000) begin  // 8 on display 1  \n            errors++;\n            $display(\"Error: Display 1 showing digit 8 failed\");\n        end\n    end\n    \n    $display(\"Testbench completed with %0d errors\", errors);\n    if (errors == 0)\n        $display(\"All tests PASSED!\");\n    else\n        $display(\"Some tests FAILED!\");\n        \n    $finish;\nend\n\n// Monitor for debugging\ninitial begin\n    $monitor(\"Time=%0t, reset=%b, enabler=%b, disp0_en=%b, disp1_en=%b, digit0=%h, digit1=%h, seg0=%b, seg1=%b\", \n             $time, reset, dut.enabler, disp0_en, disp1_en, digit0_in, digit1_in, seg0_out, seg1_out);\nend\nendmodule\n\n\nFirst prompt\nThe first prompt centered around ramking our lab but from ai. This prompt centered around time multiplexing for the 7-segment display. Once ran on Radiant, the simulation outputted an error about looping, saying:\nError 35901282 Synthesis ERROR &lt;35901282&gt; - c:/users/drgonzales/e155-lab1-main/fpga/src/lab2/lab2/source/impl_1/aiproto.sv(101): loop count limit exceeded forever never breaks. VERI-1282 [aiproto.sv:101]\nThis error suggests that a loop within the code is looping forever, specifically on line 101. The overall output coming from the Ai, however was correct, it had the right idea of time multiplexing, using the HSOSC from the FPGA, and had correct logic for the mux and 7-segment display.\n\n\nSecond prompt\nThe second prompt had the same idea as the first, however the design files from this lab were also uploaded to compare our .sv files to the code the ai produced. The error that came after synthesis in Radiant was:\nError 1025000 Synthesis ERROR &lt;1025000&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab2/lab2/source/impl_1/aiproto2.vm(26): syntax error near ‘@’\nThis error, however, was confusing in that I did not see a syntax error at this @. This may have been the ai used some sneaky syntaax when c reating the verilog that the synthesis is not used to, but overall the “always_ff @” was used correclty in my opinion. Furthermore, the rest of the code was organized correctly, with correct combinational logic."
  },
  {
    "objectID": "labs/lab1.html#introduction",
    "href": "labs/lab1.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a development board incorporating an MCU, an FPGA, and LEDs was created as the platform for exploring embedded systems. A design was implemented on the FPGA to control a 7-segment LED display and three individual LEDs. Once this lab is completed, four switches will have the capability of displaying all hexadecimal digits on the 7-segment display, and will be able to control two other LED’s based on combinational logic. The third LED will be controlled by a High-Speed Oscillator (HSOSC) have have a blink frequency of 2.4Hz.\nThe design was developed using SystemVerilog, a hardware description language, and was tested using Intels Questa, a logic waveform simulator."
  },
  {
    "objectID": "labs/lab1.html#technical-documentation",
    "href": "labs/lab1.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\n\nEquations\nTo find the overall input current for the design the formula V-Vf-IR=0 was used. The knowns for this equation are Vin, which is 3.3V, Vf, which is 2.1V, and the resistance used was 162Ω based on how bright the light was. Using this, the current comes out to 7.41mA, which is the upperbound of acceptable current going into FPGA pins.\nNext, to be able to solve for the correct clock cycles to correctly toggle led[2], solve first for time by doing 1/F, which is 0.416 seconds for two toggles (on and off). Then divide this by 2 to get 1 toggle (on), which is 0.208 seconds. Finally, to solve for amount of cycles the equation is N = t(toggle)* frequency(clk). Solving for this, N comes out to be 10,000,000 cycles.\nBlock Diagram\n\n\n\nFigure 1: This block diagram shows the connection between the MCU, FPGA, and LEDs used in Lab 1.\n\n\nThe block diagram pictured above in Figure 1 displays the internal design of the components used in our FPGA and the 7-segment display. Within the FPGA is pictured an AND gate, an XOR gate, an HSOSC (used as a clock divider), and a combinational logic block used to light our LED’s.\nWiring Schematic\n\n\n\nFigure 2: This schematic shows the wiring and components between our dev board and the 7-segment display\n\n\nFigure 2 above pictures the electrical circuit related to the FPGA and the 7-segment display. It portrays both modules along with the pins used for each module, and the necessary switches, LED’s, and pull down resistors needed. All output LED’s used were connected to 162Ω resistors to limit the input current directed toward the FPGA."
  },
  {
    "objectID": "labs/lab1.html#results-and-discussion",
    "href": "labs/lab1.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design implemented onto the FPGA met the primary objective of this lab, which was to display hexadecimal digits on the 7-segment display and control three onboard LEDs. The design created was also very accurate in its ability to display all sixteen hexadecimal values clearly, with each digit easily distinguishable from the others. The timing performance was reliable, and no noticeable delays or glitches occurred during operation. Furthermore, all three LED’s responded correctly to the switch inputs which showed that the logic was implemented correctly on the FPGA.\n\nTestbench Simulation\nThe following simulations were run on Intel’s Questa. This was done to visually see the waveforms created as a result of the logic used. To complete this simulation, a testbench was created to run test vectors through the logic created. Every couple of clock cycles a new combination of switches will be ran through the logic to test accuracy. The testbench then records the clock, the inputs, the outputs, and the expected outputs based on the test vectors.\n7-segment Display Simulation\n\n\n\nFigure 3: Above pictures the waveforms corresponding to the combinational logic used for the 7-segment display\n\n\nAbove shows a successful simulation of our 7-segment display. Each output corresponds to the expected output which shows correct usage of combinational logic within out 7-segment module.\nLED Display Simulation\n\n\n\nFigure 4: Above pictures the waveforms corresponding to the logic used for flashing Led[0] and Led[1]\n\n\nAbove again shows a successful simulation but for the three LED’s. Each output again corresponds to the expected output which suggests that our LED’s will perform correctly when wired together. Not pictured above is Led[2], which was validated using an oscilliscope.\nTop Module Simulation\n\n\n\nFigure 5: Above pictures the waveforms corresponding to the top module for the implemented design\n\n\nAbove is the overall module from our implemented design. It shows both outputs, their expected values, and the input into our system. This simulation was another success based on our outputs and the expected outputs from our test vectors."
  },
  {
    "objectID": "labs/lab1.html#conclusion",
    "href": "labs/lab1.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design created successfully showed all hexadecimal digits on the 7-segment display, and blinked three LED’s based on four input switches. This lab was completed in 12 hours."
  },
  {
    "objectID": "labs/lab1.html#ai-prototype",
    "href": "labs/lab1.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "AI Prototype",
    "text": "AI Prototype\n\nBelow is the code generated from Claude, an LLM specializing in programming.\nmodule led_blinker ( output logic led );\n// Internal oscillator clock signal\nlogic clk_48mhz;\n\n// Counter for frequency division\n// 48MHz / 2Hz = 24M counts per half period\n// Need 25 bits to count up to 24M (2^25 = 33.5M)\nlogic [24:0] counter;\n\n// LED state register\nlogic led_state;\n\n// Instantiate the internal high-frequency oscillator\n// HFOSC primitive for UP5K - runs at 48 MHz\nSB_HFOSC #(\n    .CLKHF_DIV(\"0b00\")  // No division, full 48 MHz\n) hfosc_inst (\n    .CLKHFPU(1'b1),     // Power up the oscillator\n    .CLKHFEN(1'b1),     // Enable the oscillator\n    .CLKHF(clk_48mhz)   // 48 MHz output clock\n);\n\n// Calculate the count needed for 2 Hz toggle (1 Hz blink)\n// 48,000,000 / 4 = 12,000,000 counts per quarter period\n// This gives us 2 Hz toggle rate (1 Hz visible blink)\nlocalparam logic [24:0] TOGGLE_COUNT = 25'd12_000_000;\n\n// Counter and LED control logic\nalways_ff @(posedge clk_48mhz) begin\n    if (counter &gt;= TOGGLE_COUNT - 1) begin\n        counter &lt;= '0;              // Reset counter using SystemVerilog syntax\n        led_state &lt;= ~led_state;    // Toggle LED state\n    end else begin\n        counter &lt;= counter + 1'b1;\n    end\nend\n\n// Output assignment\nassign led = led_state;\nendmodule\n\n\nCode Review\nThe output from the LLM from above is pretty sophisticated. It hosts the correct inputs and outputs, and the module initializes the HSOSC to blink a frequency of 2 Hz. The only problem that was encountered with the output from this LLM is that it did not get the correct clock High-Speed Oscillator library. The error can be seen below.\nINFO &lt;2043018&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab1/source/impl_1/Ailab1.sv(1,8-1,14) (VERI-1018) compiling module ‘AiLab1’ WARNING &lt;2043063&gt; - C:/Users/drgonzales/e155-lab1-main/fpga/src/lab1/source/impl_1/Ailab1.sv(18,5-24,7) (VERI-1063) instantiating unknown module ‘SB_HFOSC’ Done: design load finished with (0) errors, and (4) warnings\nRadiant (the synthesizer) hosts a wide variety of libraries that pertain to different FPGA’s. Claude probably got confused on which library to use as a result. However, the overall logic generated by Claude flowed well and showed no errors on the synthesizer. Next time when using Claude, or any LLM, be sure to correctly outline which libraries to be used for each module."
  },
  {
    "objectID": "labs/lab1.html#references",
    "href": "labs/lab1.html#references",
    "title": "E155 portfolio",
    "section": "References",
    "text": "References\nClass website"
  },
  {
    "objectID": "labs/lab3.html#introduction",
    "href": "labs/lab3.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a design made to take an input from a keypad, and display the output onto a time multiplexed seven-segment display. Lab 2 covered time multiplexing in depth, and this lab is build off of that along with adding a Finite State Machine (FSM) to control specific inputs and outputs. The 7-segment display will display the current number pressed on the right, and the left will display the number that was pressed in the past. This design was implemented on an FPGA with an input of {rows} and reset from the keypad, and an output of cols, disp1, disp2, and seg.\nThe design was developed using SystemVerilog, a hardware description language, and was tested using Intels Questa, a logic waveform simulator."
  },
  {
    "objectID": "labs/lab3.html#technical-documentation",
    "href": "labs/lab3.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\n\nEquations\nNote* The first two equations below were copied from lab 2\nTo be able to solve for the correct clock cycles to correctly see both digits, we repeat the formula solved in lab 2. First use a frequency in which the human cannot see flickering. This was guessed at around 240 Hz. Then do 1/F to get time = 0.00416 seconds. Then divide this by 2 to get 1 toggle (on), which is 0.002083 seconds. Finally, to solve for amount of cycles the equation is N = t(toggle)* frequency(clk). Solving for this, N comes out to be 100,000 cycles.\nThirdly, to find the overall input current for the 7-segment display, the formula V-Vf-Vs-IR=0 was used. The knowns for this equation are Vin, which is 3.3V, Vf, which is around 1.9V, Vs which is 0.25 (the Collector-Emmiter saturation), and the resistance used was 1kΩ based on how bright the light was. Using this, the current comes out to 1.15 mA, which is an acceptable current.\nLastly for the keypad [new], the internal resistors of the FPGA were used, setting the resistance to 100kΩ.\nBlock Diagram\n\n\n\nFigure 1: This block diagram shows the connection between the FPGA, its inside hardware, and the keypad utilized in lab 3.\n\n\nThe block diagram above portrays the modules used for this lab design. It includes the top module, the state machine, the controller, decoder, synchronizer, and the inputs and outputs of each module.\nRegisters\nBelow are the registers for each coresponding module for the block diagram. Each register contains a clock and a reset input. \nFigure 2 shows the registers used for our controlseg module.\n\n\n\nFigure 3: This block diagram shows the registers for the sync module.\n\n\nThe register above portrays the registers used for our sychronizer. Each flip flop is on the same clock (int_osc).\n\n\n\nFigure 4: This block diagram shows the registers for the top module.\n\n\nThe above registers were used for the clock divider for our HSOSC clock.\nWiring Schematic\n\n\n\nFigure 5: This schematic shows the wiring and components between our dev board, the 7-segment display, and the keypad.\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design.\nFinite State Machine\n\n\n\nFigure 6: Above is the state machine used for the design.\n\n\nAbove pictures the FSM created for this lab. It features five states, each with inputs and outputs (except drive). It starts at Idle, where the reset is placed."
  },
  {
    "objectID": "labs/lab3.html#results-and-discussion",
    "href": "labs/lab3.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nThe design that was uploaded to the FPGA was a success. It correctly flickered the 7-segment display (built off of last lab) and correctly displayed the input from the keypad onto the 7-segment display, with the most recent digit on the right, and the past digit on the left. The design was not successfull in the way it handled edge cases (such as holding down a button and pressing another one). This is the one spec I did not meet.\n\nTestbench Simulation\nThe following simulations were run on Intel’s Questa. This was done to visually see the waveforms created as a result of the logic used. To complete this simulation, a testbench was created to run test vectors through the logic created. Each testbench below was written different.\nFor the 7-segment testbench design, a testvector file was created to run through all possible switch inputs and outputs to our 7-segment display. The difference between this design and lab 2 was I directly converted from the input rows to the segment output. In lab 2 i converted to hex first.\nSecondly, the schronizer module testbench, a test was done by throwing in rows into the module, and recording the specific output, and comparing them to the expected.\nThirdly, the controller module testbench, sort of the same idea but there was a mux that controlled the system, and an enabler for the flip flops. Tests were added for the mux inputs and outputs.\nFourthly, the state module testbench, rows were inputted into the module and internal signals were analyzed based on these inputs. This was useful in visually seeing the change of state, and to easily follow, the state machine and its outputs.\nLastly, to test the top module, three edge cases were inputted into the system to see if they reacted in the way intended. Internal signals were used to determine when things went wrong.\n7-segment Display Simulation\n\n\n\nFigure 7: Above pictures the waveforms corresponding to the combinational logic used for the 7-segment display\n\n\nAbove is waveform simulation for the the 7-segment display design. This design was purely combinational logic, and shows the conversion from the debounced row input to the segment output.\nSchronizer Simulation\n\n\n\nFigure 8: Above pictures the waveforms corresponding to the logic used for the schronizer\n\n\nFigure 8 shows the simulation for the schronizer design. This design was simple, and it just cheked that after two clock cycles, the output got the same input.\nController Simulation\n\n\n\nFigure 9: Above pictures the waveforms corresponding to the controller\n\n\nFigure 9 shows the controller simulation. It hosts the same idea as the schronizer, however the design had to take account for the mux, and ifferent enablers, which is seen above.\nState machine Simulation\n\n\n\nFigure 10: Above pictures the waveforms corresponding to the FSM\n\n\nAbove shows the overall state machine, and its inputs and outputs. The design of the testbench implemented hosted just a test of different inputs, and instead of a typical testbench throwing back errors, waveforms can be visually seen to check whether the deisng implemnted worked.\nTop Module Simulation\n\n\n\nFigure 11: Above pictures the waveforms corresponding to the top module\n\n\nAbove is the final simulation made for this design. It throws in inputs and tests the expected outputs. The internal signals were also helpful in this module to test that things were flowing correclty throughout the module. It is also helpful to see the full layout of asynchronous and synchronous design."
  },
  {
    "objectID": "labs/lab3.html#conclusion",
    "href": "labs/lab3.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design created was a successs. With each segment on the 7-segment display illuminating at the correct frequency (repeat from lab 2), and correctly displaying the output from a keypad onto the 7-segment display. However, there was one setback in which when one button was pressed, then another, realsed the first one, it did not register the next one correctly. This would happen in the same row and collumn of the original button pressed. Thus I did not meet the excellence spec for this lab."
  },
  {
    "objectID": "labs/lab3.html#suggestions",
    "href": "labs/lab3.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nTo maybe look at internal signals more when checking waveforms. Its much easier to see whats wrong rather than assert statements."
  },
  {
    "objectID": "labs/lab3.html#ai-prototype",
    "href": "labs/lab3.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai prototype",
    "text": "Ai prototype\n\nBelow are the prompts for the AI prototype\n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\n\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement:\nA clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\nTarget device: Lattice iCE40 UP5K FPGA.\n\nOverall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display.\nCurrent Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior:\nWhen a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here.\n\nTarget device: Lattice iCE40 UP5K FPGA.\n\nWrite a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior:\nIterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches.\n\nTarget device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source.\n\nWrite a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements:\nUpdate the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\n\nResponse\nThe monolithic prompt in my opinion performed better than the decomposed prompt. It was simpilier and it showed no synthesized errors. The design was easy to follow sometimes, but other times it kind of just threw code together to make it “simplier” but in a sense it made it more complicated. One such example of this is below:\n                detected_key = get_key_code(2'b00, row_in[1:0] == 2'b11 ? (row_in[3:2] == 2'b11 ? 2'b11 : 2'b10) :\n                                                                          (row_in[1] ? 2'b01 : 2'b00));\nThe decomposed prompt had a better flow in a sense that the modules were seperated. It only fell short because it initiated the wrong clock when running the last prompt.\nError 35901063 Synthesis ERROR &lt;35901063&gt; - c:/users/drgonzales/e155-lab1-main/fpga/src/lab3/lab3/source/impl_1/ai1.sv(24): instantiating unknown module SB_HFOSC. VERI-1063 [ai1.sv:24]\nAbove shows the error that was thrown back from Radiant when synthesizing. The modulization created from the first prompt was relativiely good. Like i said earlier it was simplier, and with no explicit instruction, it did pretty well.\nThere was no new state or nextstae idioms in the code. They initialized the states as I would for an FSM. Here is an example:\n// FSM states typedef enum logic [1:0] { IDLE = 2’b00, // No key pressed, ready for new key DEBOUNCE = 2’b01, // Key detected, debouncing KEY_HELD = 2’b10, // Key confirmed and held RELEASE = 2’b11 // Waiting for key release } state_t;\nWhen using an LLM for my workflow again, I would kind of do both of these methods. I would want it simpler for me to understand, however I would want it to seperate like it did in the second prompt"
  },
  {
    "objectID": "labs/lab6.html#introduction",
    "href": "labs/lab6.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a design was made to use a microcontroller, the SPI interface, and the UART interface to build and design an IoT device. One first part of this design incorporated an SPI link between the microcontroller and a DS1722 temperature sensor. This link was written over the peripherals, MISO, MOSI, CE, and SYSCLK. The next part was an UART connection between the microcontroller and a ESP8266 wifi module. The wifi module would output the temperature values and the resolution coming from the microcontroller. As the final part of the design, a website was created within the microcontroller to output the temperature values and the user is able to control the temperture resolution, and an onboard LED.\nThe design was developed using C on SEGGER, and implemented on an STM32L432KC Microcontroller."
  },
  {
    "objectID": "labs/lab6.html#technical-documentation",
    "href": "labs/lab6.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\nThe documentation for the STM32L432KC manual Github link.\nThe documentation for the DS1722 Github link.\nThe documentation for the ESP8266 Github repo.\n\nEquations\nThere were no equations used for this lab.\n\n\nExample DS1722 Register Address\nTo be able to control the resolution of the tempertaure sensor, the user must look at the datasheet and write and read from the correct registers. Along with this, Proper modes and enabling bits also need to be written to ensure synchronization.\n\n\n\nFigure 1: Below is the register map for the DS1722\n\n\n\nLogic Analyzer\nThis overall design was tested using the Logic Analyzer option on an Oscilliscope. This function performs the same as the FPGA waveforms that we have seen in previous labs. It portrays all essential parts of the SPI protocol, which include the clock, enabler, MISO and MOSI.\n\n\n\nFigure 2: Above is the Logic Analyzer for this design\n\n\nAbove are clearly shown the enabler(D9), the clock(D10), MISO(D11), and MOSI(D12). On the bottom we can see the clear outputs from the MOSI and MISO. On the MISO wave, first see the sensor waiting for an input read/write. Once this first instruction is sent from MOSI (226), which is the starting resolution, we see dont see an output in MISO because we are writing. However once we read the LSB and MSB registers as shown in MOSI, the MISO changes accordingly to show the output value of 24.218, which is around what we expected around room temperature.\nWiring Schematic\n\n\n\nFigure 3: This schematic shows the wiring and components between our dev board, the ESP8266, the DS1722, and the onboard LED\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design."
  },
  {
    "objectID": "labs/lab6.html#results-and-discussion",
    "href": "labs/lab6.html#results-and-discussion",
    "title": "E155 portfolio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nPrinted Temperature Values\nFor this lab, a website was created to be able to toggle an LED on and off, and control the resolution of a tempertaure sensor, the output of the seen can be seen below.\n\n\n\nFigure 4: Below is an example of the output from the website"
  },
  {
    "objectID": "labs/lab6.html#conclusion",
    "href": "labs/lab6.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was a success. The microcontroller successfully was linked via SPI to the DS1722, and via UART to the ESP8266. Along with this, a webiste was created successfully to read the temperature values over wifi from the ESP8266, and the user was able to change and control a LED, and the resolution of the temperature sensor.\nThis Lab took 12 hours."
  },
  {
    "objectID": "labs/lab6.html#suggestions",
    "href": "labs/lab6.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nTo, in future labs, better understand the SPI interface beforehand and understand how it compares to other communication protocols such as I2C or I2S.\nThis lab took me 15 hours."
  },
  {
    "objectID": "labs/lab6.html#ai-prototype",
    "href": "labs/lab6.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "Ai prototype",
    "text": "Ai prototype\nHere is the AI prototype for this lab. Posted below is the prompt that was plugged into Claude AI: 1. I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nBelow is the output from the LLM.\n\n\n\nFigure 5: HDML website created by Claude\n\n\nThe LLM did not output any code.\n\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\nOutput code:\n/** * DS1722 Temperature Sensor SPI Driver for STM32L432KC * Using CMSIS libraries */\n#include “stm32l4xx.h” #include &lt;stdint.h&gt;\n// DS1722 Register Addresses #define DS1722_REG_CONFIG 0x80 #define DS1722_REG_TEMP_LSB 0x01 #define DS1722_REG_TEMP_MSB 0x02\n// DS1722 Configuration bits #define DS1722_CONFIG_SHUTDOWN 0x01 #define DS1722_CONFIG_ONESHOT 0x10 #define DS1722_CONFIG_RES_8BIT 0x00 #define DS1722_CONFIG_RES_9BIT 0x02 #define DS1722_CONFIG_RES_10BIT 0x04 #define DS1722_CONFIG_RES_11BIT 0x06 #define DS1722_CONFIG_RES_12BIT 0x08\n// GPIO Configuration (adjust pins as needed) #define SPI_CS_PIN 4 // PA4 for CS #define SPI_SCK_PIN 5 // PA5 for SCK #define SPI_MISO_PIN 6 // PA6 for MISO #define SPI_MOSI_PIN 7 // PA7 for MOSI\n/** * Initialize SPI1 peripheral for DS1722 communication * Assumes system clock is already configured */ void DS1722_SPI_Init(void) { // Enable clocks for GPIOA and SPI1 RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN; RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;\n// Configure GPIO pins for SPI1 (PA5=SCK, PA6=MISO, PA7=MOSI)\n// Set alternate function mode (AF5 for SPI1)\nGPIOA-&gt;MODER &= ~(GPIO_MODER_MODE5 | GPIO_MODER_MODE6 | GPIO_MODER_MODE7);\nGPIOA-&gt;MODER |= (GPIO_MODER_MODE5_1 | GPIO_MODER_MODE6_1 | GPIO_MODER_MODE7_1);\n\n// Set alternate function AF5 (SPI1) for PA5, PA6, PA7\nGPIOA-&gt;AFR[0] &= ~(GPIO_AFRL_AFSEL5 | GPIO_AFRL_AFSEL6 | GPIO_AFRL_AFSEL7);\nGPIOA-&gt;AFR[0] |= (5 &lt;&lt; GPIO_AFRL_AFSEL5_Pos) | \n                 (5 &lt;&lt; GPIO_AFRL_AFSEL6_Pos) | \n                 (5 &lt;&lt; GPIO_AFRL_AFSEL7_Pos);\n\n// Set high speed for SPI pins\nGPIOA-&gt;OSPEEDR |= (GPIO_OSPEEDR_OSPEED5 | GPIO_OSPEEDR_OSPEED6 | GPIO_OSPEEDR_OSPEED7);\n\n// Configure PA4 as CS (Chip Select) - output, push-pull\nGPIOA-&gt;MODER &= ~GPIO_MODER_MODE4;\nGPIOA-&gt;MODER |= GPIO_MODER_MODE4_0;\nGPIOA-&gt;OTYPER &= ~GPIO_OTYPER_OT4;\nGPIOA-&gt;OSPEEDR |= GPIO_OSPEEDR_OSPEED4;\n\n// Set CS high (inactive)\nGPIOA-&gt;BSRR = (1 &lt;&lt; SPI_CS_PIN);\n\n// Configure SPI1\n// Disable SPI for configuration\nSPI1-&gt;CR1 &= ~SPI_CR1_SPE;\n\n// Configure SPI: Master mode, CPOL=0, CPHA=0, 8-bit data\n// Baud rate: fPCLK/16 (assuming 80MHz PCLK, this gives ~5MHz SPI clock)\nSPI1-&gt;CR1 = SPI_CR1_MSTR |           // Master mode\n            SPI_CR1_SSM |             // Software slave management\n            SPI_CR1_SSI |             // Internal slave select\n            (3 &lt;&lt; SPI_CR1_BR_Pos);    // Baud rate: fPCLK/16\n\nSPI1-&gt;CR2 = (7 &lt;&lt; SPI_CR2_DS_Pos) |  // 8-bit data size\n            SPI_CR2_FRXTH;            // RXFIFO threshold\n\n// Enable SPI\nSPI1-&gt;CR1 |= SPI_CR1_SPE;\n}\n/** * Send/receive a single byte via SPI */ static uint8_t SPI_TransferByte(uint8_t data) { // Wait until TX buffer is empty while (!(SPI1-&gt;SR & SPI_SR_TXE));\n// Send data\n*(__IO uint8_t *)&SPI1-&gt;DR = data;\n\n// Wait until RX buffer has data\nwhile (!(SPI1-&gt;SR & SPI_SR_RXNE));\n\n// Read and return received data\nreturn *(__IO uint8_t *)&SPI1-&gt;DR;\n}\n/** * Assert CS (Chip Select) - pull low */ static inline void DS1722_CS_Low(void) { GPIOA-&gt;BSRR = (1 &lt;&lt; (SPI_CS_PIN + 16)); // Reset bit }\n/** * Deassert CS (Chip Select) - pull high */ static inline void DS1722_CS_High(void) { GPIOA-&gt;BSRR = (1 &lt;&lt; SPI_CS_PIN); // Set bit }\n/** * Write to DS1722 register */ void DS1722_WriteRegister(uint8_t reg, uint8_t value) { DS1722_CS_Low(); SPI_TransferByte(reg); // Send register address SPI_TransferByte(value); // Send data DS1722_CS_High(); }\n/** * Read from DS1722 register */ uint8_t DS1722_ReadRegister(uint8_t reg) { uint8_t value;\nDS1722_CS_Low();\nSPI_TransferByte(reg);          // Send register address\nvalue = SPI_TransferByte(0x00); // Dummy byte to read data\nDS1722_CS_High();\n\nreturn value;\n}\n/** * Configure DS1722 sensor * resolution: DS1722_CONFIG_RES_8BIT to DS1722_CONFIG_RES_12BIT */ void DS1722_Configure(uint8_t resolution) { // Write configuration: continuous conversion mode with specified resolution DS1722_WriteRegister(DS1722_REG_CONFIG, resolution); }\n/** * Simple delay function (approximate, not precise) / static void delay_ms(uint32_t ms) { // Assumes 80MHz system clock, adjust as needed for (uint32_t i = 0; i &lt; ms  8000; i++) { __NOP(); } }\n/** * Read temperature from DS1722 sensor * Returns temperature in degrees Celsius as a float * * The DS1722 stores temperature in two registers: * - MSB: Integer part (signed) * - LSB: Fractional part (upper bits) */ float DS1722_ReadTemperature(void) { int8_t temp_msb; uint8_t temp_lsb; float temperature;\n// Read temperature registers\ntemp_msb = (int8_t)DS1722_ReadRegister(DS1722_REG_TEMP_MSB);\ntemp_lsb = DS1722_ReadRegister(DS1722_REG_TEMP_LSB);\n\n// Calculate temperature based on resolution\n// LSB bits represent fractional part: bit7=0.5, bit6=0.25, bit5=0.125, etc.\ntemperature = (float)temp_msb;\ntemperature += (temp_lsb &gt;&gt; 5) * 0.125f;  // Upper 3 bits for 12-bit resolution\n\nreturn temperature;\n}\n/** * Initialize and read temperature from DS1722 * Example usage function */ float DS1722_GetTemperature(void) { static uint8_t initialized = 0;\n// Initialize SPI and sensor on first call\nif (!initialized) {\n    DS1722_SPI_Init();\n    delay_ms(10);  // Wait for sensor to power up\n    DS1722_Configure(DS1722_CONFIG_RES_12BIT);  // 12-bit resolution\n    delay_ms(250); // Wait for first conversion (max 240ms for 12-bit)\n    initialized = 1;\n}\n\n// Read and return temperature\nreturn DS1722_ReadTemperature();\n}\nHere are a few ideas of on what you might comment on:\nI think the Quality of both was really good. I liked the HTML page, however just based on glance without running I can tell that the code for the SPI and the sensor was wrong. This is due to the code saying that the sensor is active low, meaning it probably did not read the datasheet. This is what I noticed at first glance, and because you cannot switch the sensors hardware around, this code is faulty. Compared to my setup it was fine. My had the same idea hwoever it was just written completely differently. The SPI setup was around the same however. The LLLM chose an input clock of 5MHZ which is an acceptable range for the sensor, which can have inputs up to 10MHZ. The LLM works well for creating the initial idea and overall structure. But its code is faulty due to it not reading the datasheet correctly."
  },
  {
    "objectID": "labs/lab5.html#introduction",
    "href": "labs/lab5.html#introduction",
    "title": "E155 portfolio",
    "section": "Introduction",
    "text": "Introduction\nIn this lab, a design was made to use a microcontroller to determine the speed of a brushed DC motor by reading a quadrature encoder using interrupts. To do this, code was written in C to sense quadrature encoder pulses, and in turn, turn those pulses into motor velocities. The function of a quadrature encoder is to use an incremental motion sensor that uses two output signals offset by 90 degrees to provide both positional and directional information for a motor. An animation of an encoder can be see below.\n\n\n\nFigure 1: Animation of quadrature encoder\n\n\nAbove is the quadrature encoder used for this lab. The disk rotates with the motor.\nThe design was developed using C on SEGGER, and implemented on an STM32L432KC Microcontroller."
  },
  {
    "objectID": "labs/lab5.html#technical-documentation",
    "href": "labs/lab5.html#technical-documentation",
    "title": "E155 portfolio",
    "section": "Technical Documentation",
    "text": "Technical Documentation\nThe source code for this lab can be found in this GitHub repo.\nThe documentation for the STM32L432KC manual Github link.\nThe source Instruction to cycles documentation ARM website.\n\nEquations\nThe only equations applicable to this lab are the ones used to calculate how many edges to account for. The equation used was:\nrevolutions = position (1000/timer) / (4 x 408)\nThis equation multiplies the encoder count (position counter) by the sampling rate (samples per second), then divides by the total number of quadrature edges per revolution.\nAn example of this equation in the works can be seen below. Below is an osilliscope frame of the output of the B encoder. This occured at 10V input into the motor.\n\n\n\nFigure 2: Animation of quadrature encoder\n\n\nEach square wave period corresponds to one pulse of the encoder signal. The frequency of these pulses increases with motor speed, which is directly controlled by the input voltage.\nWe know that f = 1/T -&gt; 970Hz\nUsing the relationship between speed, frequency, and PPR we get:\nspeed (rev/s) = f / PPR -&gt; 2.37 rev/s\nWhen comparing this to the actual value measured by our interrupts, we can see the same value. As seen below:\n\n\n\nFigure 3: Speed values printed in debug terminal\n\n\nAbove are the values that we were getting from our debug terminal from our interrupt code. These values, when compared to our theoretical values, are within a 1% margin. Thus validating the output coming from our code.\nFlowchart\nBelow is my logic flowchart for this lab. It features important calls to certain functions, and goes through the flow for the main loop within this design.\n\n\n\nFigure 4: Flowchart\n\n\nFigure 4 shows the functions: main, initAB, GPIOenable, timeable, and the interupt handler EXTI_IRQHandler.\nWiring Schematic\n\n\n\nFigure 5: Circuit Diagram\n\n\nAbove pictures the electrical circuit for our design. It portrays all electrical components used for the design. The design was pretty straightforward, just ensure to use the correct 5V input pins. Most of the pins on the STM32L432KC are only 3.3 logic input."
  },
  {
    "objectID": "labs/lab5.html#results",
    "href": "labs/lab5.html#results",
    "title": "E155 portfolio",
    "section": "Results",
    "text": "Results\nThe results of this lab were a success. The MC correctly recorded the rev/s of the motor for low and high speeds using interupts and timers. Two interupts were used for each edge of the encoder (A and B), and a timer was used for the 1/2 second delay for the display."
  },
  {
    "objectID": "labs/lab5.html#interrupt-vs-polling",
    "href": "labs/lab5.html#interrupt-vs-polling",
    "title": "E155 portfolio",
    "section": "Interrupt vs polling",
    "text": "Interrupt vs polling\nBefore this lab I thought that polling would be a more efficient option compared to anything else. Polling is just something that I was used to when doing Systemverilog, or Python, however I think the difference between interrupts and polling is huge. To reinstate their overall differences:\nInterrupts are a hardware-driven mechanism that temporarily pause the CPU’s current task to handle a specific event (such as a GPIO input change). Once the interrupt service routine (ISR) finishes executing, the CPU returns to its previous task. This approach can be more efficient because the CPU only reacts when needed, reducing unnecessary processing and potentially lowering power consumption.\nPolling, in contrast, continuously checks the status of an input in a loop. The CPU repeatedly reads the GPIO pin and processes the data even if nothing has changed. This method is simpler to implement but uses more CPU time and power since the processor is always active and waiting for pins to go high or low.\nMathematically, their difference can be represented by the following:\nTo analyze polling for this lab, we consider reading a GPIO pin continuously and executing a conditional statement on each iteration. We also write this value. The example polling file can be seen below:\n\n\n\nFigure 6: Code for manual polling\n\n\nTo be able to tell how fast this polling occurs we need to seperate this code into instructions, then estimate how many cycles per instruction there are to be able to decide the overall frequency of the while loop. The assembly instruction for the code above can be found below. Given by SEGGER.\n\n\n\nFigure 7: Assembly instructions\n\n\nAbove is the general instructions for the code given. However it does not include the instructions for the called functions. Those, however WERE included in the calculation.\nHowever we need to know how many individual cycles for each instruction we have so we can calculate how many instructions total. The link above in the Technical Documentation tab is from the ARM website for the CORTEX M-4. ARM, the designer for the CORTEX M-4 series, documented how many cycles for each instruction.\nFrom this, we can calculate how many cycles our whole polling code takes.\nThis number comes out to around 97 cycles in the condition that each branch instr is 2 cycles, and that we did not include the delay_millis or the while (UIF).\nBack to our earlier calculations, we find the frequency of polling using a CPU freq of 80 Mhz.\nf = (CPU freq) / cycles -&gt; 824,742.268 Hz\nWith a period of:\nt (latency) = 1/f -&gt; 1.21 μs\nUsing our f we can find the max speed:\nspeed(max) = 824,742.268 (edges/s) / 816 edges/rev = 1010.71 rev/s\nIn the polling approach, the CPU executes the GPIO read loop continuously, using nearly 100% of processing time, even when no edges occur.\nComparing this to interrupt, the same steps were completed as before. Below is the assembly instructions used.\n\n\n\nFigure 8: Assembly for interrupt code\n\n\nThe cycles calculated were 57 cycles with 408 * 2 edges (we are only utilizing one encoder, but both edges) (We arent counting direction)\nEach encoder edge triggers an interrupt, so the CPU only does work when an event occurs.\nCPU time = (57 * 816) / CPU freq -&gt; 0.058 %\nSo interrupts only use 0.058% of CPU time when counting up to 1 full revolution, leaving the other 99.95% for other tasks.\nThe latency for the interrupts is 12 cycles which can be found here: Cortex-M4 Technical Reference Manual\nThe interrupt hardware latency, i.e., the time from the encoder edge to the first instruction of the ISR, is:\nt (latency) = 12/ CPU freq = 0.15 μs\nUsing our f we can find the max speed:\n1/t = 6,666,666 Hz\nspeed(max) = f edges/s / 816 edges/rev = 8169.9 rev /s\nThus, compared to polling, interrupts significantly reduce CPU usage while providing near-instantaneous response to encoder events.\nAt higher speeds the encoder can generate edges faster than the polling loop can check them. Thus, some edges may be missed because the CPU hasn’t completed the current loop iteration. However when running interrupts they are event-driven, so each encoder edge triggers the ISR immediately, regardless of overall motor speed.\nBelow is a summary table of the mathematical differences between the two.\n\n\n\nFigure 9: Summary Table"
  },
  {
    "objectID": "labs/lab5.html#conclusion",
    "href": "labs/lab5.html#conclusion",
    "title": "E155 portfolio",
    "section": "Conclusion",
    "text": "Conclusion\nThe design was a success uploaded for this lab was a success. The STM32L432KC correctly took the input from the encoder, and provided speed and directional data. This lab was done using the CMSIS code provided by STM unlike lab 4. This made the code more structured and provided more readability for the reader.\nThis Lab took 13 hours."
  },
  {
    "objectID": "labs/lab5.html#suggestions",
    "href": "labs/lab5.html#suggestions",
    "title": "E155 portfolio",
    "section": "Suggestions",
    "text": "Suggestions\nGo through and understand each CMSIS file, and understand the stm32L4xxx header file."
  },
  {
    "objectID": "labs/lab5.html#ai-prototype",
    "href": "labs/lab5.html#ai-prototype",
    "title": "E155 portfolio",
    "section": "AI Prototype",
    "text": "AI Prototype\nThis is the AI prototype for this lab. The prompt that was ran through Claude AI was:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThe code that was produced as a result was :\n/  Quadrature Encoder Interface using TIM2 on STM32L432KC * Encoder connections: * Channel A -&gt; PA0 (TIM2_CH1) * Channel B -&gt; PA1 (TIM2_CH2) */\n#include “stm32l4xx_hal.h”\nTIM_HandleTypeDef htim2; volatile int32_t encoder_count = 0; volatile int32_t encoder_overflow = 0;\n/* Initialize encoder interface */ void Encoder_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; TIM_Encoder_InitTypeDef sEncoderConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0};\n/* Enable clocks */\n__HAL_RCC_GPIOA_CLK_ENABLE();\n__HAL_RCC_TIM2_CLK_ENABLE();\n\n/* Configure GPIO pins PA0 and PA1 for TIM2 encoder input */\nGPIO_InitStruct.Pin = GPIO_PIN_0 | GPIO_PIN_1;\nGPIO_InitStruct.Mode = GPIO_MODE_AF_PP;\nGPIO_InitStruct.Pull = GPIO_PULLUP;\nGPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;\nGPIO_InitStruct.Alternate = GPIO_AF1_TIM2;\nHAL_GPIO_Init(GPIOA, &GPIO_InitStruct);\n\n/* Configure TIM2 in encoder mode */\nhtim2.Instance = TIM2;\nhtim2.Init.Prescaler = 0;\nhtim2.Init.CounterMode = TIM_COUNTERMODE_UP;\nhtim2.Init.Period = 0xFFFFFFFF;  // 32-bit counter\nhtim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;\nhtim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;\n\n/* Encoder configuration: count on both edges of both channels */\nsEncoderConfig.EncoderMode = TIM_ENCODERMODE_TI12;\nsEncoderConfig.IC1Polarity = TIM_ICPOLARITY_RISING;\nsEncoderConfig.IC1Selection = TIM_ICSELECTION_DIRECTTI;\nsEncoderConfig.IC1Prescaler = TIM_ICPSC_DIV1;\nsEncoderConfig.IC1Filter = 10;  // Input filtering\nsEncoderConfig.IC2Polarity = TIM_ICPOLARITY_RISING;\nsEncoderConfig.IC2Selection = TIM_ICSELECTION_DIRECTTI;\nsEncoderConfig.IC2Prescaler = TIM_ICPSC_DIV1;\nsEncoderConfig.IC2Filter = 10;\n\nif (HAL_TIM_Encoder_Init(&htim2, &sEncoderConfig) != HAL_OK)\n{\n    Error_Handler();\n}\n\nsMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;\nsMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;\nif (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)\n{\n    Error_Handler();\n}\n\n/* Set counter to middle value to allow bidirectional counting */\n__HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF);\n\n/* Enable update interrupt for overflow/underflow detection */\n__HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);\n\n/* Configure NVIC */\nHAL_NVIC_SetPriority(TIM2_IRQn, 0, 0);\nHAL_NVIC_EnableIRQ(TIM2_IRQn);\n\n/* Start encoder interface */\nHAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);\n}\n/* TIM2 interrupt handler */ void TIM2_IRQHandler(void) { if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE) != RESET) { if (__HAL_TIM_GET_IT_SOURCE(&htim2, TIM_IT_UPDATE) != RESET) { __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);\n        /* Check direction to determine overflow or underflow */\n        if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2))\n        {\n            encoder_overflow--;  // Underflow\n        }\n        else\n        {\n            encoder_overflow++;  // Overflow\n        }\n    }\n}\n}\n/* Get current encoder position */ int32_t Encoder_GetCount(void) { int32_t cnt = (int32_t)(__HAL_TIM_GET_COUNTER(&htim2)) - 0x7FFFFFFF; return cnt; }\n/* Get absolute position including overflows */ int64_t Encoder_GetAbsoluteCount(void) { int32_t cnt = Encoder_GetCount(); int64_t total = ((int64_t)encoder_overflow &lt;&lt; 32) + cnt; return total; }\n/* Reset encoder count */ void Encoder_Reset(void) { __HAL_TIM_SET_COUNTER(&htim2, 0x7FFFFFFF); encoder_overflow = 0; }\n/* Get encoder direction (1 = forward, -1 = reverse, 0 = stopped) */ int8_t Encoder_GetDirection(void) { if (__HAL_TIM_IS_TIM_COUNTING_DOWN(&htim2)) return -1; else return 1; }\n/* Example usage in main */ int main(void) { HAL_Init(); SystemClock_Config();\nEncoder_Init();\n\nwhile (1)\n{\n    int32_t position = Encoder_GetCount();\n    int8_t direction = Encoder_GetDirection();\n    \n    // Use encoder data here\n    HAL_Delay(10);\n}\n}\n/* Weak error handler - implement your own */ __weak void Error_Handler(void) { __disable_irq(); while (1) { } }\n/* Weak system clock config - implement based on your setup */ __weak void SystemClock_Config(void) { // Configure your system clock here }\nRelated questions:\nHow would you rate the quality of the output and why?\nI think the output produced is a little confusing. It has overall weird syntax that have not seen regarding the stm32Lxxx.h header. One example of this can be seen in ‘HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);’. Almost everywhere in the code i see the ‘HAL’ notation but i am quite unsure what this notation means.\nDid the LLM generate any code for you? If so, how does it compare to your setup?\nLike explained above, it uses irregular syntax from what I am used to. This caused me to be confused. This syntax might be correct however as I dont know the full extent to the stm32L4xxx header.\nHow does the LLM’s explanation compare to your reasoning for choosing your timer?\nThe same timer was chosen. This is just one of the basic overall timers used within the STM32.\nDoes the LLM work well as a sounding board, rather than a code generator as used in previous prototypes?\nI think the LLM works well in giving you overall strcuture for the code and giving you the overall idea of what your code should generally look like. This can be important in fomrulating ideas, but is bad if you dont know where to look for the correct functions within the header file."
  },
  {
    "objectID": "posts/reflection1.html",
    "href": "posts/reflection1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Initial reaction to Lab 1 of Microp? It was alot. The code itself wasnt that bad, but the software we used to program the FPGA was just horrible. It took around 10 minutes to load each time, and when you finally were able to load it, it would not recognize your FPGA was plugged in unless you crashed the site 100 times.\nOnce you get past this leap, everything else was pretty easy. Questa ran as normal, and running the testbenches were pretty fun. The hardware itself was fun to solder, and overall put together. I had one mishap where a wire in my circuit was faulty, and it took me an hour to debug, but thats the engineering process. I put fourth a lot of effort into this lab having been doing it for aorund 18 hours. It was rewarding when it was finally completed and I updated all of the side specifications."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 portfolio",
    "section": "",
    "text": "Hello! My name is Drake Gonzales and I am a Junior Engineering major at Harvey Mudd College. I am interested in studying computer and electrical engineering, with a specific focus in Lithography. This website, created with Quarto, posseses all of my work that I have completed in E155 “Microprocessor System:Design & Application”\nDate created: 8/27/2025"
  },
  {
    "objectID": "project/project.html",
    "href": "project/project.html",
    "title": "Midpoint Checkoff: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "As of today, we are on track for our final deliverables for this lab. That being said, as of right now we can play full unfiltered audio from a computer to a 3.5mm jack, an ADC, an FPGA, a DAC, and another 3.5mm jack to a set of two stereo speakers.\nInital struggles for this design was first fully integrating a top module to already pre-written Lattice I2S code. The Lattice code is open-source and was written to be able to recieve and transmit data over I2S protocol. The struggle with this however was to learn how to latch the input data from the ADC to the correct posedge/negedge to the bitclk and LRclk. Without proper synchronization this data can become metastable and never really latch internally, which is what we originally had. The latch was originaly written in combinational logic with a basic dac_data is assigned to adc_data. However this failed due to the non-sychrnoization based on what our clocks were running at, and the output from this yielded garbage analog data. Once written correctly (that is, now it is synched to a clk), audio was able to cross from the ADC -&gt; FPGA -&gt; DAC with no problem.\nSecondly, this lab was very difficult because of the use of different input voltage ranges from the ADC and the computer. Initial thoughts were that there was no data coming from the external jack from the computer. However, after careful research, we came to the conclusion that the data from a MAC just centered at 0, which doesnt nesessarily mean no data, it just means that it is scaled to be in that voltage range, which in our case was -0.8V to 0.8V. To combat this, an non-inverting op-amp circuit was created to shift the voltages from the MAC, to an acceptable range to the ADC. This shift resulted in a new scale of around 2.5V, which sucessfully created a good digital output from the ADC.\n\n\nWe having written a filtering module, and are still trying to debug a subtle issue with the coefficients. It works for unity gain, but not with non-zero coefficients. We are unsure if this is a timing issue, bit manipulation issue, or a coefficient issue. It is plausible that the hardware works as intended but our calculations for coefficients are off.\nWe are also not manually instantiating the DSP blocks, but first going to write a naive version and see how it performs. For now, it seems to be keeping up fine. We can handle a slight delay, but do not want noticable latency.\n\n\n\nAll parts have been ordered (ADC, DAC, audio jacks), as all other parts (opamps, resistors, trim pots, etc.) are all from the stockroom.\n\n\n\n\nPlaying unfiltered Audio\nSPI connection between MCU and FPGA (from lab 7)\nRX/TX Chain\nLeft and Right Audio separation\n\n\n\n\n\nDebug filtering issue\nImplement ADC for knobs on MCU ## Technical Diagrams\n\nThe source code for this lab can be found in this GitHub repo.\nThe datasheet for the Op-amp can be found in this Technical document.\nThe datasheet for the DAC can be found in this Technical document.\nThe datasheet for the ADC can be found in this Technical document.\n\n\n\nBelow are images for all electronic components for this lab. Non on-board parts used for this lab are a DAC, ADC, Op-amp, Speakers, and an external laptop.\n\n\n\nFigure 1: The schematic above shows all electric components for this lab included with electronic parts.\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design.\n\n\n\nFigure 2: This schematic shows op-amp circuit created to shift voltages into the ADC.\n\n\n\n\n\nFor completion of the mid-point checkoff we needed a block diagram to show the overall interfaces / protocols used for this lab. The main ones used are I2S, and SPI communication. I2S was used for communication between the ADC -&gt; FPGA -&gt; DAC. This protocol was created by Lattice, the designer of the FPGA. SPI communication was created in lab 6, however ADC initilization is needed to take in the input from the speakers.\n\n\n\nFigure 3: This Block diagram shows parts and all interfaces used for this lab"
  },
  {
    "objectID": "project/project.html#overview",
    "href": "project/project.html#overview",
    "title": "Midpoint Checkoff: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "As of today, we are on track for our final deliverables for this lab. That being said, as of right now we can play full unfiltered audio from a computer to a 3.5mm jack, an ADC, an FPGA, a DAC, and another 3.5mm jack to a set of two stereo speakers.\nInital struggles for this design was first fully integrating a top module to already pre-written Lattice I2S code. The Lattice code is open-source and was written to be able to recieve and transmit data over I2S protocol. The struggle with this however was to learn how to latch the input data from the ADC to the correct posedge/negedge to the bitclk and LRclk. Without proper synchronization this data can become metastable and never really latch internally, which is what we originally had. The latch was originaly written in combinational logic with a basic dac_data is assigned to adc_data. However this failed due to the non-sychrnoization based on what our clocks were running at, and the output from this yielded garbage analog data. Once written correctly (that is, now it is synched to a clk), audio was able to cross from the ADC -&gt; FPGA -&gt; DAC with no problem.\nSecondly, this lab was very difficult because of the use of different input voltage ranges from the ADC and the computer. Initial thoughts were that there was no data coming from the external jack from the computer. However, after careful research, we came to the conclusion that the data from a MAC just centered at 0, which doesnt nesessarily mean no data, it just means that it is scaled to be in that voltage range, which in our case was -0.8V to 0.8V. To combat this, an non-inverting op-amp circuit was created to shift the voltages from the MAC, to an acceptable range to the ADC. This shift resulted in a new scale of around 2.5V, which sucessfully created a good digital output from the ADC.\n\n\nWe having written a filtering module, and are still trying to debug a subtle issue with the coefficients. It works for unity gain, but not with non-zero coefficients. We are unsure if this is a timing issue, bit manipulation issue, or a coefficient issue. It is plausible that the hardware works as intended but our calculations for coefficients are off.\nWe are also not manually instantiating the DSP blocks, but first going to write a naive version and see how it performs. For now, it seems to be keeping up fine. We can handle a slight delay, but do not want noticable latency.\n\n\n\nAll parts have been ordered (ADC, DAC, audio jacks), as all other parts (opamps, resistors, trim pots, etc.) are all from the stockroom.\n\n\n\n\nPlaying unfiltered Audio\nSPI connection between MCU and FPGA (from lab 7)\nRX/TX Chain\nLeft and Right Audio separation\n\n\n\n\n\nDebug filtering issue\nImplement ADC for knobs on MCU ## Technical Diagrams\n\nThe source code for this lab can be found in this GitHub repo.\nThe datasheet for the Op-amp can be found in this Technical document.\nThe datasheet for the DAC can be found in this Technical document.\nThe datasheet for the ADC can be found in this Technical document.\n\n\n\nBelow are images for all electronic components for this lab. Non on-board parts used for this lab are a DAC, ADC, Op-amp, Speakers, and an external laptop.\n\n\n\nFigure 1: The schematic above shows all electric components for this lab included with electronic parts.\n\n\nAbove pictures the electrical circuit for our design. It portrays resistors, and all other electrical components used for the design.\n\n\n\nFigure 2: This schematic shows op-amp circuit created to shift voltages into the ADC.\n\n\n\n\n\nFor completion of the mid-point checkoff we needed a block diagram to show the overall interfaces / protocols used for this lab. The main ones used are I2S, and SPI communication. I2S was used for communication between the ADC -&gt; FPGA -&gt; DAC. This protocol was created by Lattice, the designer of the FPGA. SPI communication was created in lab 6, however ADC initilization is needed to take in the input from the speakers.\n\n\n\nFigure 3: This Block diagram shows parts and all interfaces used for this lab"
  },
  {
    "objectID": "project/project.html#microcontroller-routines",
    "href": "project/project.html#microcontroller-routines",
    "title": "Midpoint Checkoff: Real Time 3-Band EQ Filtering",
    "section": "Microcontroller Routines",
    "text": "Microcontroller Routines\nAs mentioned before we have not done many things on the MCU yet far, only research into how ADC is initialized. Below is a Routies / block diagram for how we will use the MCU in the coming weeks.\n\n\n\nFigure 4: This Block diagram shows parts and all interfaces used for this lab"
  },
  {
    "objectID": "project/project.html#conclusion",
    "href": "project/project.html#conclusion",
    "title": "Midpoint Checkoff: Real Time 3-Band EQ Filtering",
    "section": "Conclusion",
    "text": "Conclusion\nI think this project is going fairly well thus far in terms of how far we have come. I think we need to work better on time manageent in terms of simulation for modules we have created."
  },
  {
    "objectID": "project/project.html#suggestions",
    "href": "project/project.html#suggestions",
    "title": "Midpoint Checkoff: Real Time 3-Band EQ Filtering",
    "section": "Suggestions",
    "text": "Suggestions\nGoing forward, our group needs to finish filtering audio from the ADC fully. Then use a potentiometer and calibrate these filters via SPI protocol from the MCU. The only high bottoleneck going forward is the setup for the onboard ADC on the MCU."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Additional course resources",
    "section": "",
    "text": "Class website: https://hmc-e155.github.io/\nE155 development board schematic: https://hmc-e155.github.io/assets/doc/E155_v4_Dev_Board_BOM.html\nSTM32 MCU manuel: https://hmc-e155.github.io/assets/doc/rm0394-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf\nICE40 FPGA manual: https://hmc-e155.github.io/assets/doc/FPGA-DS-02008-2-0-iCE40-UltraPlus-Family-Data-Sheet.pdf\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]